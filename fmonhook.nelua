## pragmas.nogc = true
## context.globalpragmas.nocstaticassert = true

require 'sys'
require 'string'
require 'hashmap'

local RESTART_DELAY <comptime> = 20
local initialized = false
local handling_signal = false
local child_pid: cint = 0
local root_pid: cint = getpid()
local filter = '%.h$'
local time_checkpoint: timespec
local tracked_files: hashmap(string, boolean)
local FopenFunc = @function(cstring, cstring): *FILE
local orig_fopen: FopenFunc
local orig_fopen64: FopenFunc

local function monitor_file(filename: string): boolean
  local pid = fork() -- fork in two processes
  assert(pid >= 0, 'fork failed')
  if pid == 0 then -- let the child process continue
    setpgid(0, 0) -- set a new process group for the child
    return false
  end
  -- parent process will only monitor the file
  child_pid = pid
  local inotify_fd = inotify_init()
  assert(inotify_fd >= 0, 'failed to initialize inotify')
  local inotify_mask: cint = IN_MODIFY | IN_CREATE | IN_DELETE_SELF | IN_MOVE_SELF
  local inotify_wid = inotify_add_watch(inotify_fd, filename, inotify_mask) -- watch the file
  assert(inotify_wid >= 0, 'failed to watch file')
  local buf: [1024]byte -- buffer for inotify events
  while true do -- keep waiting the file to change indefinitely
    local res = read(inotify_fd, nilptr, 0) -- wait for an event
    if res == -1 and errno == EINTR then -- interrupted by a signal (like Ctrl+C on terminal)
      killwait(root_pid, SIGUSR2) -- recursive kill all children processes
    end
    msleep(RESTART_DELAY) -- wait some time so all file changes can flush
    local len = read(inotify_fd, &buf, #buf) -- wait an inotify event
    if len > 0 then -- got an inotify event, must be a file change
      print('filed changed: ', filename)
      killwait(pid, SIGUSR2) -- propagate children kill and wait them to finish
      pid = fork() -- fork in two processes
      assert(pid >= 0, 'fork failed')
      if pid == 0 then -- let the child process continue
        setpgid(0, 0) -- set a new process group for the child
        local now = tostring(uticks())
        setenv("FMON_RESTART_TICKS", now, 1)
        now:destroy()
        return true
      end
      child_pid = pid
    end
  end
  return false -- actually unreachable
end

-- Called once a file is opened.
local function track_file_open(name: cstring, mode: cstring, fp: *FILE): boolean
  if not initialized or -- ignore when the library was not initialized yet
     not fp or -- skip failed opens
     mode == 'w' then -- skip write only
    return false
  end
  local filename = resolvpath(name)
  defer filename:destroy() end
  if filename == '' or -- skip failed path resolutions
     filename:find('^/tmp') ~= 0 or -- skip temporary files
     filename:find(filter) == 0 or -- skip files not in the filter
     tracked_files:peek(filename) then -- skip files already tracked
    return false
  end
  print('track', filename)
  tracked_files:set(string.copy(filename), true)
  local res = monitor_file(filename)
  return res
end

-- Signal handler.
local function signal_handler(signum: cint)
  if handling_signal then -- signal already being handled, this should hardly happen
    return
  end
  handling_signal = true
  if child_pid ~= 0 then -- propagate kill on child process
    killwait(child_pid, SIGUSR2)
  end
  killwait(-getpid(), SIGKILL) -- kill all spawned sub processes
end

do -- initialize
  -- setup signal handler, used to recursively propagate kill signal on children processes
  assert(signal(SIGUSR2, signal_handler) == 0, 'failed to setup signal handler')
  initialized = true
end

-- C `fopen` hook.
local function fopen(filename: cstring <const>, mode: cstring <const>): *FILE <cexport, codename 'fopen'>
  if not orig_fopen then
    orig_fopen = (@FopenFunc)(dlsym(RTLD_NEXT, "fopen"))
  end
  local fp: *FILE = orig_fopen(filename, mode)
  if track_file_open(filename, mode, fp) then -- file changed, we need to open again
    fclose(fp)
    fp = orig_fopen(filename, mode)
  end
  return fp
end

-- C `fopen64` hook.
local function fopen64(filename: cstring <const>, mode: cstring <const>): *FILE <cexport, codename 'fopen64'>
  if not orig_fopen64 then
    orig_fopen64 = (@FopenFunc)(dlsym(RTLD_NEXT, "fopen64"))
  end
  local fp: *FILE = orig_fopen64(filename, mode)
  if track_file_open(filename, mode, fp) then -- file changed, we need to open again
    fclose(fp)
    fp = orig_fopen64(filename, mode)
  end
  return fp
end

-- Shared library entry point.
local function setup() <entrypoint, cattribute 'constructor'>
  local function nelua_main(argc: cint, argv: *cstring): cint <cimport,nodecl> end
  nelua_main(0, nilptr)
end
