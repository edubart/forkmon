## pragmas.nogc = true
## context.globalpragmas.nocstaticassert = true

require 'sys'
require 'string'
require 'hashmap'

local RESTART_DELAY <comptime> = 20
local IGNORE_DELAY <comptime> = 200
local initialized: boolean = false
local handling_signal: boolean = false
local parent_inotify_fd: cint = -1
local child_pid: cint = 0
local root_pid: cint = getpid()
local last_restart_ticks: uint64
local filter: string = '%.nelua$'
local time_checkpoint: timespec
local tracked_files: hashmap(string, boolean)
local FopenFunc: type = @function(cstring, cstring): *FILE
local orig_fopen: FopenFunc
local orig_fopen64: FopenFunc

-- Create a new inotify instance and add file to watch.
local function inotify_init_watch(filename: string, mask: cint): (cint, cint)
  local fd = inotify_init()
  assert(fd >= 0, 'failed to initialize inotify')
  local wd = inotify_add_watch(fd, filename, mask) -- watch the file
  assert(wd >= 0, 'failed to watch file')
  return fd, wd
end

-- Monitor a file for changes, returns true when the filed changed.
local function monitor_file(filename: string): boolean
  local inotify_mask: cint = IN_MODIFY | IN_CREATE | IN_DELETE_SELF | IN_MOVE_SELF
  if parent_inotify_fd >= 0 then -- a parent process restarted due to a file change
    -- lets just add this file to track in the parent inotify fd
    -- so we can avoid lot's of forks when changing the same file
    print('track dep', filename)
    local inotify_wd = inotify_add_watch(parent_inotify_fd, filename, inotify_mask) -- watch the file
    assert(inotify_wd >= 0, 'failed to watch file')
    return false
  end
  print('track', filename)
  local pid = fork() -- fork in two processes
  assert(pid >= 0, 'fork failed')
  if pid == 0 then -- let the child process continue
    setpgid(0, 0) -- set a new process group for the child
    return false
  end
  -- parent process will only monitor the file
  child_pid = pid
  local inotify_fd, inotify_wd = inotify_init_watch(filename, inotify_mask)
  local buf: [1024]byte -- buffer for inotify events
  while true do -- keep waiting the file to change indefinitely
    local res = read(inotify_fd, nilptr, 0) -- wait for an event
    if res == -1 and errno == EINTR then -- interrupted by a signal (like Ctrl+C on terminal)
      killwait(root_pid, SIGUSR2) -- recursive kill all children processes
    end
    msleep(RESTART_DELAY) -- wait some time so all file changes can flush
    local len = read(inotify_fd, &buf, #buf) -- wait an inotify event
    if len > 0 then -- got an inotify event, must be a file change
      local now: uint64 = uticks()
      if now - last_restart_ticks <= IGNORE_DELAY*1000 then
        continue -- changed too soon, just ignore
      end
      last_restart_ticks = now
      local wdchange = false
      local pos: cint = 0
      while pos < len do
        local event: *inotify_event = (@*inotify_event)(&buf[pos])
        if event.wd == inotify_wd then
          wdchange = true
          break
        end
        pos = pos + #inotify_event + event.len
      end
      if wdchange then
        print('file changed: ', filename)
        parent_inotify_fd = inotify_fd
      else
        print('a dep file changed')
        parent_inotify_fd = -1
        -- reinitialize inotify to cleanup all old watches
        close(inotify_fd)
        inotify_fd, inotify_wd = inotify_init_watch(filename, inotify_mask)
      end
      killwait(pid, SIGUSR2) -- propagate children kill and wait them to finish
      pid = fork() -- fork in two processes
      assert(pid >= 0, 'fork failed')
      if pid == 0 then -- let the child process continue
        setpgid(0, 0) -- set a new process group for the child
        local nowtext = tostring(now)
        setenv("FMON_RESTART_TICKS", nowtext, 1)
        nowtext:destroy()
        return true
      end
      child_pid = pid
    end
  end
  return false -- actually unreachable
end

-- Called once a file is opened.
local function track_file_open(name: cstring, mode: cstring, fp: *FILE): boolean
  if not initialized or -- ignore when the library was not initialized yet
     not fp or -- skip failed opens
     mode == 'w' then -- skip write only
    return false
  end
  local filename = resolvpath(name)
  defer filename:destroy() end
  if filename == '' or -- skip failed path resolutions
     filename:find('^/tmp') ~= 0 or -- skip temporary files
     filename:find(filter) == 0 or -- skip files not in the filter
     tracked_files:peek(filename) then -- skip files already tracked
    return false
  end
  tracked_files:set(string.copy(filename), true)
  local res = monitor_file(filename)
  return res
end

-- Signal handler.
local function signal_handler(signum: cint)
  if handling_signal then -- signal already being handled, this should hardly happen
    return
  end
  handling_signal = true
  if child_pid ~= 0 then -- propagate kill on child process
    killwait(child_pid, SIGUSR2)
  end
  killwait(-getpid(), SIGKILL) -- kill all spawned sub processes
end

do -- initialize
  -- setup signal handler, used to recursively propagate kill signal on children processes
  assert(signal(SIGUSR2, signal_handler) == 0, 'failed to setup signal handler')
  initialized = true
end

-- C `fopen` hook.
local function fopen(filename: cstring <const>, mode: cstring <const>): *FILE <cexport, codename 'fopen'>
  if not orig_fopen then
    orig_fopen = (@FopenFunc)(dlsym(RTLD_NEXT, "fopen"))
  end
  local fp: *FILE = orig_fopen(filename, mode)
  if track_file_open(filename, mode, fp) then -- file changed, we need to open again
    fclose(fp)
    fp = orig_fopen(filename, mode)
  end
  return fp
end

-- C `fopen64` hook.
local function fopen64(filename: cstring <const>, mode: cstring <const>): *FILE <cexport, codename 'fopen64'>
  if not orig_fopen64 then
    orig_fopen64 = (@FopenFunc)(dlsym(RTLD_NEXT, "fopen64"))
  end
  local fp: *FILE = orig_fopen64(filename, mode)
  if track_file_open(filename, mode, fp) then -- file changed, we need to open again
    fclose(fp)
    fp = orig_fopen64(filename, mode)
  end
  return fp
end

-- Shared library entry point.
local function setup() <entrypoint, cattribute 'constructor'>
  local function nelua_main(argc: cint, argv: *cstring): cint <cimport,nodecl> end
  nelua_main(0, nilptr)
end
