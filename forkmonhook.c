/* Generated by Nelua 0.2.0-dev */
/* Compile command: gcc "forkmonhook.c" -o "forkmonhook" -Wall -fwrapv -g -ldl -lm */
/* Compile hash: 2orUKYk2oDaCwFtWouKm1EGLfKzk */
/* ------------------------------ DECLARATIONS ------------------------------ */
#ifdef __GNUC__
#pragma GCC diagnostic error   "-Wimplicit-function-declaration"
#pragma GCC diagnostic error   "-Wimplicit-int"
#pragma GCC diagnostic ignored "-Wincompatible-pointer-types"
#pragma GCC diagnostic ignored "-Wmissing-braces"
#pragma GCC diagnostic ignored "-Wmissing-field-initializers"
#pragma GCC diagnostic ignored "-Wtype-limits"
#pragma GCC diagnostic ignored "-Wunused-parameter"
#if defined(__clang__)
#pragma GCC diagnostic ignored "-Wunused"
#else
#pragma GCC diagnostic ignored "-Wunused-variable"
#pragma GCC diagnostic ignored "-Wunused-function"
#pragma GCC diagnostic ignored "-Wunused-but-set-variable"
#pragma GCC diagnostic ignored "-Wdiscarded-qualifiers"
#endif
#endif
#define _GNU_SOURCE
#include <dlfcn.h>
#include <stdlib.h>
#include <stdio.h>
#include <errno.h>
#include <time.h>
__asm__(".symver clock_gettime,clock_gettime@GLIBC_2.2.5");
#include <signal.h>
#include <unistd.h>
#include <sys/wait.h>
#include <sys/inotify.h>
#include <stdint.h>
#include <stddef.h>
#include <stdbool.h>
#include <string.h>
#include <ctype.h>
#include <inttypes.h>
#include <stdarg.h>
typedef struct nlstring nlstring;
typedef uint8_t* nluint8_arr0_ptr;
struct nlstring {
  nluint8_arr0_ptr data;
  uintptr_t size;
};
static nlstring sys_Colors_Yellow = {(uint8_t*)"\033[33m", 5};
static nlstring sys_Colors_Red = {(uint8_t*)"\033[31m", 5};
static nlstring sys_Colors_Reset = {(uint8_t*)"\033[0m", 4};
typedef struct timespec timespec;
static void sys_usleep(uint64_t ms);
static uint64_t sys_uticks();
static int sys_killwait(int pid, int sig);
static bool sys_filexists(char* path);
#ifdef __GNUC__
#define nelua_inline __attribute__((always_inline)) inline
#elif __STDC_VERSION__ >= 199901L
#define nelua_inline inline
#else
#define nelua_inline
#endif
static nelua_inline void nelua_memory_copy(void* dest, void* src, uintptr_t n);
static nelua_inline int32_t nelua_memory_compare(void* a, void* b, uintptr_t n);
static nelua_inline bool nelua_memory_equals(void* a, void* b, uintptr_t size);
#ifdef __GNUC__
#define nelua_likely(x) __builtin_expect(x, 1)
#define nelua_unlikely(x) __builtin_expect(x, 0)
#else
#define nelua_likely(x) (x)
#define nelua_unlikely(x) (x)
#endif
typedef uint8_t* nluint8_ptr;
static void* nelua_memory_find(void* haystack, uintptr_t haystacksize, void* needle, uintptr_t needlesize);
typedef struct nlmulret_nlboolean_nlint64_nlstring {
  bool r1;
  int64_t r2;
  nlstring r3;
} nlmulret_nlboolean_nlint64_nlstring;
typedef struct nelua_sequence_string nelua_sequence_string;
typedef struct nelua_sequenceimpl_string nelua_sequenceimpl_string;
typedef nelua_sequenceimpl_string* nelua_sequenceimpl_string_ptr;
typedef struct nelua_span_string nelua_span_string;
typedef nlstring* nlstring_arr0_ptr;
struct nelua_span_string {
  nlstring_arr0_ptr data;
  uintptr_t size;
};
struct nelua_sequenceimpl_string {
  nelua_span_string data;
  uintptr_t size;
};
typedef struct nelua_GeneralAllocator nelua_GeneralAllocator;
struct nelua_GeneralAllocator {};
struct nelua_sequence_string {
  nelua_sequenceimpl_string_ptr impl;
  nelua_GeneralAllocator allocator;
};
typedef nlmulret_nlboolean_nlint64_nlstring (*function_LVr5rP9wJyrc2Fjq)(nelua_sequence_string, int64_t);
typedef struct nlmulret_function_LVr5rP9wJyrc2Fjq_nelua_sequence_string_nlint64 {
  function_LVr5rP9wJyrc2Fjq r1;
  nelua_sequence_string r2;
  int64_t r3;
} nlmulret_function_LVr5rP9wJyrc2Fjq_nelua_sequence_string_nlint64;
static nelua_inline nlmulret_nlboolean_nlint64_nlstring nelua_ipairs_next(nelua_sequence_string a_1, int64_t k);
static nelua_inline nlmulret_function_LVr5rP9wJyrc2Fjq_nelua_sequence_string_nlint64 nelua_ipairs_1(nelua_sequence_string a);
typedef struct nelua_span_uint8 nelua_span_uint8;
typedef nelua_span_uint8* nelua_span_uint8_ptr;
struct nelua_span_uint8 {
  nluint8_arr0_ptr data;
  uintptr_t size;
};
static nelua_inline nluint8_ptr nelua_span_uint8___atindex(nelua_span_uint8_ptr self, uintptr_t i);
typedef nlstring* nlstring_ptr;
typedef nelua_span_string* nelua_span_string_ptr;
static nelua_inline nlstring_ptr nelua_span_string___atindex(nelua_span_string_ptr self, uintptr_t i);
typedef uint32_t* nluint32_ptr;
typedef struct nelua_span_uint32 nelua_span_uint32;
typedef nelua_span_uint32* nelua_span_uint32_ptr;
typedef uint32_t* nluint32_arr0_ptr;
struct nelua_span_uint32 {
  nluint32_arr0_ptr data;
  uintptr_t size;
};
static nelua_inline nluint32_ptr nelua_span_uint32___atindex(nelua_span_uint32_ptr self, uintptr_t i);
typedef struct nelua_FStream nelua_FStream;
typedef nelua_FStream* nelua_FStream_ptr;
typedef FILE* FILE_ptr;
typedef int (*function_2Mqcy4RvYDajcBaXs)(FILE_ptr);
struct nelua_FStream {
  FILE_ptr fp;
  function_2Mqcy4RvYDajcBaXs closef;
};
typedef struct nelua_span_FStream nelua_span_FStream;
typedef nelua_span_FStream* nelua_span_FStream_ptr;
typedef nelua_FStream* nelua_FStream_arr0_ptr;
struct nelua_span_FStream {
  nelua_FStream_arr0_ptr data;
  uintptr_t size;
};
static nelua_inline nelua_FStream_ptr nelua_span_FStream___atindex(nelua_span_FStream_ptr self, uintptr_t i);
typedef uintptr_t* nlusize_ptr;
typedef struct forkmonhook_span_usize forkmonhook_span_usize;
typedef forkmonhook_span_usize* forkmonhook_span_usize_ptr;
typedef uintptr_t* nlusize_arr0_ptr;
struct forkmonhook_span_usize {
  nlusize_arr0_ptr data;
  uintptr_t size;
};
static nelua_inline nlusize_ptr forkmonhook_span_usize___atindex(forkmonhook_span_usize_ptr self, uintptr_t i);
typedef struct forkmonhook_hashmap_node_nil forkmonhook_hashmap_node_nil;
typedef forkmonhook_hashmap_node_nil* forkmonhook_hashmap_node_nil_ptr;
struct forkmonhook_hashmap_node_nil {
  nlstring key;
  bool value;
  uintptr_t next;
};
typedef struct forkmonhook_span_hashmap_node_nil forkmonhook_span_hashmap_node_nil;
typedef forkmonhook_span_hashmap_node_nil* forkmonhook_span_hashmap_node_nil_ptr;
typedef forkmonhook_hashmap_node_nil* forkmonhook_hashmap_node_nil_arr0_ptr;
struct forkmonhook_span_hashmap_node_nil {
  forkmonhook_hashmap_node_nil_arr0_ptr data;
  uintptr_t size;
};
static nelua_inline forkmonhook_hashmap_node_nil_ptr forkmonhook_span_hashmap_node_nil___atindex(forkmonhook_span_hashmap_node_nil_ptr self, uintptr_t i);
static nelua_inline void nelua_memory_spanset_1(forkmonhook_span_usize dest, uintptr_t x);
typedef struct nelua_PatternMatcherCapture nelua_PatternMatcherCapture;
typedef nelua_PatternMatcherCapture* nelua_PatternMatcherCapture_ptr;
struct nelua_PatternMatcherCapture {
  intptr_t init;
  intptr_t len;
};
static bool nelua_PatternMatcherCapture_is_unfinished(nelua_PatternMatcherCapture_ptr self);
static bool nelua_PatternMatcherCapture_is_position(nelua_PatternMatcherCapture_ptr self);
typedef struct nelua_PatternMatcher nelua_PatternMatcher;
struct nelua_PatternMatcher {
  nlstring source;
  nlstring pattern;
  intptr_t depth;
  intptr_t numcaptures;
  nelua_PatternMatcherCapture capture[32];
};
static nelua_PatternMatcher nelua_PatternMatcher_create(nlstring source, nlstring pattern);
typedef nelua_PatternMatcher* nelua_PatternMatcher_ptr;
#if __STDC_VERSION__ >= 201112L
#define nelua_noreturn _Noreturn
#elif defined(__GNUC__)
#define nelua_noreturn __attribute__((noreturn))
#else
#define nelua_noreturn
#endif
static nelua_noreturn void nelua_abort();
static void _nelua_assert_line1(bool cond, nlstring msg);
static void _nelua_assert_line2(bool cond, nlstring msg);
static nlstring nelua_PatternMatcher_get_capture(nelua_PatternMatcher_ptr self, intptr_t i);
static bool nelua_match_class(uint8_t c, uint8_t cl);
static void _nelua_assert_line3(bool cond, nlstring msg);
static void _nelua_assert_line4(bool cond, nlstring msg);
static intptr_t nelua_match_class_end(nelua_PatternMatcher_ptr ms_1, intptr_t p_1);
static bool nelua_match_bracket_class(nelua_PatternMatcher_ptr ms_2, uint8_t c, intptr_t p_2, intptr_t ep);
static bool nelua_match_single(nelua_PatternMatcher_ptr ms_3, intptr_t s_1, intptr_t p_3, intptr_t ep);
static void _nelua_assert_line5(bool cond, nlstring msg);
static intptr_t nelua_match_balance(nelua_PatternMatcher_ptr ms_4, intptr_t s_2, intptr_t p_4);
static intptr_t nelua_match_max_expand(nelua_PatternMatcher_ptr ms_5, intptr_t s_3, intptr_t p_5, intptr_t ep);
static intptr_t nelua_match_min_expand(nelua_PatternMatcher_ptr ms_6, intptr_t s_4, intptr_t p_6, intptr_t ep);
static void _nelua_assert_line6(bool cond, nlstring msg);
static intptr_t nelua_match_start_capture(nelua_PatternMatcher_ptr ms_7, intptr_t s_5, intptr_t p_7, intptr_t what);
static void _nelua_assert_line7(bool cond, nlstring msg);
static intptr_t nelua_match_end_capture(nelua_PatternMatcher_ptr ms_8, intptr_t s_6, intptr_t p_8);
static void _nelua_assert_line8(bool cond, nlstring msg);
static intptr_t nelua_match_capture(nelua_PatternMatcher_ptr ms_9, intptr_t s_7, uint8_t l);
static void _nelua_assert_line9(bool cond, nlstring msg);
static void _nelua_assert_line10(bool cond, nlstring msg);
static intptr_t nelua_PatternMatcher__match(nelua_PatternMatcher_ptr ms, intptr_t s, intptr_t p);
static bool nelua_match_has_pattern_specials(nlstring pattern);
typedef struct nlmulret_nlisize_nlisize {
  intptr_t r1;
  intptr_t r2;
} nlmulret_nlisize_nlisize;
static nlmulret_nlisize_nlisize nelua_PatternMatcher_match(nelua_PatternMatcher_ptr ms, intptr_t init, bool plain);
#ifdef __GNUC__
#define nelua_noinline __attribute__((noinline))
#else
#define nelua_noinline
#endif
typedef nelua_sequence_string* nelua_sequence_string_ptr;
static nelua_noinline void nelua_sequence_string__grow(nelua_sequence_string_ptr self);
static void nelua_sequence_string_init(nelua_sequence_string_ptr self);
static nelua_inline nlstring_ptr nelua_sequence_string___atindex(nelua_sequence_string_ptr self, uintptr_t i);
static nelua_inline intptr_t nelua_sequence_string___len(nelua_sequence_string_ptr self);
typedef nelua_GeneralAllocator* nelua_GeneralAllocator_ptr;
static nelua_inline void* nelua_GeneralAllocator_alloc(nelua_GeneralAllocator_ptr self, uintptr_t size);
static nelua_inline void* nelua_GeneralAllocator_alloc0(nelua_GeneralAllocator_ptr self, uintptr_t size);
static nelua_inline void* nelua_GeneralAllocator_realloc(nelua_GeneralAllocator_ptr self, void* p, uintptr_t newsize, uintptr_t oldsize);
static nelua_inline void nelua_GeneralAllocator_dealloc(nelua_GeneralAllocator_ptr self, void* p);
static void* nelua_GeneralAllocator_realloc0(nelua_GeneralAllocator_ptr self, void* p, uintptr_t newsize, uintptr_t oldsize);
static forkmonhook_span_usize nelua_GeneralAllocator_spanrealloc_2(nelua_GeneralAllocator_ptr self, forkmonhook_span_usize s, uintptr_t size);
static nelua_span_uint8 nelua_GeneralAllocator_spanrealloc0_1(nelua_GeneralAllocator_ptr self, nelua_span_uint8 s, uintptr_t size);
static nelua_span_string nelua_GeneralAllocator_spanrealloc0_2(nelua_GeneralAllocator_ptr self, nelua_span_string s, uintptr_t size);
static nelua_span_uint32 nelua_GeneralAllocator_spanrealloc0_3(nelua_GeneralAllocator_ptr self, nelua_span_uint32 s, uintptr_t size);
static nelua_span_FStream nelua_GeneralAllocator_spanrealloc0_4(nelua_GeneralAllocator_ptr self, nelua_span_FStream s, uintptr_t size);
static forkmonhook_span_hashmap_node_nil nelua_GeneralAllocator_spanrealloc0_5(nelua_GeneralAllocator_ptr self, forkmonhook_span_hashmap_node_nil s, uintptr_t size);
static void nelua_GeneralAllocator_spandealloc_1(nelua_GeneralAllocator_ptr self, nelua_span_uint8 s);
static void nelua_GeneralAllocator_spandealloc_3(nelua_GeneralAllocator_ptr self, nelua_span_uint32 s);
static void nelua_GeneralAllocator_spandealloc_4(nelua_GeneralAllocator_ptr self, nelua_span_FStream s);
static void _nelua_assert_line11(bool cond, nlstring msg);
static void* nelua_GeneralAllocator_xalloc(nelua_GeneralAllocator_ptr self, uintptr_t size);
static void _nelua_assert_line12(bool cond, nlstring msg);
static void* nelua_GeneralAllocator_xalloc0(nelua_GeneralAllocator_ptr self, uintptr_t size);
static void _nelua_assert_line13(bool cond, nlstring msg);
static forkmonhook_span_usize nelua_GeneralAllocator_spanxrealloc_2(nelua_GeneralAllocator_ptr self, forkmonhook_span_usize s, uintptr_t size);
static void _nelua_assert_line14(bool cond, nlstring msg);
static nelua_span_string nelua_GeneralAllocator_spanxrealloc0_1(nelua_GeneralAllocator_ptr self, nelua_span_string s, uintptr_t size);
static void _nelua_assert_line15(bool cond, nlstring msg);
static nelua_span_uint32 nelua_GeneralAllocator_spanxrealloc0_2(nelua_GeneralAllocator_ptr self, nelua_span_uint32 s, uintptr_t size);
static void _nelua_assert_line16(bool cond, nlstring msg);
static nelua_span_FStream nelua_GeneralAllocator_spanxrealloc0_3(nelua_GeneralAllocator_ptr self, nelua_span_FStream s, uintptr_t size);
static void _nelua_assert_line17(bool cond, nlstring msg);
static forkmonhook_span_hashmap_node_nil nelua_GeneralAllocator_spanxrealloc0_4(nelua_GeneralAllocator_ptr self, forkmonhook_span_hashmap_node_nil s, uintptr_t size);
static nelua_GeneralAllocator nelua_general_allocator = {};
static nlstring nelua_nlstring__create(uintptr_t size);
typedef struct {uint8_t data[32];} nluint8_arr32;
typedef nluint8_arr32* nluint8_arr32_ptr;
static nelua_inline char* nelua_string2cstring(nlstring s);
static void _nelua_assert_line18(bool cond, nlstring msg);
static void _nelua_assert_line19(bool cond, nlstring msg);
static uintptr_t nelua_scanformat(nluint8_arr0_ptr strfmt, nluint8_arr32_ptr form);
typedef struct nelua_stringbuilderT nelua_stringbuilderT;
typedef nelua_stringbuilderT* nelua_stringbuilderT_ptr;
struct nelua_stringbuilderT {
  nelua_span_uint8 data;
  uintptr_t size;
  nelua_GeneralAllocator allocator;
};
static void nelua_stringbuilderT_destroy(nelua_stringbuilderT_ptr self);
static nluint8_arr0_ptr nelua_stringbuilderT_prepare(nelua_stringbuilderT_ptr self, uintptr_t size);
static void nelua_stringbuilderT_commit(nelua_stringbuilderT_ptr self, uintptr_t size);
static bool nelua_stringbuilderT_write_byte(nelua_stringbuilderT_ptr self, uint8_t c);
typedef struct nlmulret_nlboolean_nlcint {
  bool r1;
  int r2;
} nlmulret_nlboolean_nlcint;
static void _nelua_assert_line20(bool cond, nlstring msg);
static void _nelua_assert_line21(bool cond, nlstring msg);
static nlmulret_nlboolean_nlcint nelua_formatarg_2(nelua_stringbuilderT_ptr self, uint8_t c, char* buff, uintptr_t maxitem, nluint8_arr32_ptr form, nlstring arg1);
static nelua_inline nlstring nelua_cstring2string(char* s);
static void _nelua_assert_line22(bool cond, nlstring msg);
static void _nelua_assert_line23(bool cond, nlstring msg);
static nlmulret_nlboolean_nlcint nelua_formatarg_3(nelua_stringbuilderT_ptr self, uint8_t c, char* buff, uintptr_t maxitem, nluint8_arr32_ptr form, char* arg1);
static void _nelua_assert_line24(bool cond, nlstring msg);
static bool nelua_stringbuilderT_write_format_2(nelua_stringbuilderT_ptr self, nlstring fmt, nlstring __arg1);
static void _nelua_assert_line25(bool cond, nlstring msg);
static bool nelua_stringbuilderT_write_format_3(nelua_stringbuilderT_ptr self, nlstring fmt, char* __arg1);
static void _nelua_assert_line26(bool cond, nlstring msg);
static bool nelua_stringbuilderT_write_format_4(nelua_stringbuilderT_ptr self, nlstring fmt);
static nlstring nelua_stringbuilderT_view(nelua_stringbuilderT_ptr self);
static void nelua_nlstring_destroy(nlstring s);
static nlstring nelua_nlstring_copy(nlstring s);
typedef struct nlniltype {} nlniltype;
static nlmulret_nlisize_nlisize nelua_nlstring_find_1(nlstring s, nlstring pattern, nlniltype init, nlniltype plain);
typedef struct nlmulret_nlboolean_nlstring_nelua_span_string {
  bool r1;
  nlstring r2;
  nelua_span_string r3;
} nlmulret_nlboolean_nlstring_nelua_span_string;
typedef struct nelua_GMatchState nelua_GMatchState;
typedef nelua_GMatchState* nelua_GMatchState_ptr;
struct nelua_GMatchState {
  nelua_PatternMatcher ms;
  intptr_t init;
  nlstring captures[8];
};
typedef nlmulret_nlboolean_nlstring_nelua_span_string (*function_PhfPeGGJMcY1eas6)(nelua_GMatchState_ptr, nlstring);
typedef struct nlmulret_function_PhfPeGGJMcY1eas6_nelua_GMatchState_nlstring {
  function_PhfPeGGJMcY1eas6 r1;
  nelua_GMatchState r2;
  nlstring r3;
} nlmulret_function_PhfPeGGJMcY1eas6_nelua_GMatchState_nlstring;
static void _nelua_assert_line27(bool cond, nlstring msg);
static nlmulret_nlboolean_nlstring_nelua_span_string nelua_gmatch_next(nelua_GMatchState_ptr state, nlstring it);
static nlmulret_function_PhfPeGGJMcY1eas6_nelua_GMatchState_nlstring nelua_nlstring_gmatchview_1(nlstring s, nlstring pattern, nlniltype init);
static nelua_inline intptr_t nelua_nlstring___len(nlstring a);
static bool nelua_nlstring___eq(nlstring a, nlstring b);
typedef char* nlcchar_arr0_ptr;
static bool nelua_tocstring(nlcchar_arr0_ptr buf, uintptr_t buflen, nlstring s);
static nlstring nelua_tostring_1(uint64_t x);
typedef struct {char data[65];} nlcchar_arr65;
static void _nelua_assert_line28(bool cond);
static void _nelua_assert_line29(bool cond, nlstring msg);
static nelua_inline bool nelua_lt_nlisize_nlusize(intptr_t a, uintptr_t b);
static int64_t nelua_tointeger_1(char* x, nlniltype base);
typedef struct {char data[4097];} nlcchar_arr4097;
static nlstring sys_resolvpath(nlstring path);
static nelua_inline uintptr_t nelua_lhash(nluint8_arr0_ptr data, uintptr_t len, uintptr_t seed, uintptr_t step);
static nelua_inline uintptr_t nelua_hash_long(nelua_span_uint8 data);
static uintptr_t nelua_hash_hash_1(nlstring v);
static nelua_inline uintptr_t nelua_ceil_idiv(uintptr_t x, uintptr_t y);
typedef struct nlmulret_nlusize_nlusize_nlusize {
  uintptr_t r1;
  uintptr_t r2;
  uintptr_t r3;
} nlmulret_nlusize_nlusize_nlusize;
typedef struct forkmonhook_hashmap_stringboolean forkmonhook_hashmap_stringboolean;
typedef forkmonhook_hashmap_stringboolean* forkmonhook_hashmap_stringboolean_ptr;
struct forkmonhook_hashmap_stringboolean {
  forkmonhook_span_usize buckets;
  forkmonhook_span_hashmap_node_nil nodes;
  uintptr_t size;
  nelua_GeneralAllocator allocator;
};
static nlmulret_nlusize_nlusize_nlusize forkmonhook_hashmap_stringboolean__find(forkmonhook_hashmap_stringboolean_ptr self, nlstring key);
static nelua_noinline void forkmonhook_hashmap_stringboolean_rehash(forkmonhook_hashmap_stringboolean_ptr self, uintptr_t count);
static void forkmonhook_hashmap_stringboolean_reserve(forkmonhook_hashmap_stringboolean_ptr self, uintptr_t count);
static uintptr_t forkmonhook_hashmap_stringboolean__find_or_make(forkmonhook_hashmap_stringboolean_ptr self, nlstring key);
typedef bool* nlboolean_ptr;
static nlboolean_ptr forkmonhook_hashmap_stringboolean_peek(forkmonhook_hashmap_stringboolean_ptr self, nlstring key);
static void forkmonhook_hashmap_stringboolean_set(forkmonhook_hashmap_stringboolean_ptr self, nlstring key, bool value);
typedef struct nelua_SlotPoolT nelua_SlotPoolT;
typedef nelua_SlotPoolT* nelua_SlotPoolT_ptr;
struct nelua_SlotPoolT {
  uint32_t size;
  uint32_t queue_top;
  nelua_span_uint32 gen_ctrs;
  nelua_span_uint32 free_queue;
  nelua_GeneralAllocator allocator;
};
static void nelua_SlotPoolT_reserve(nelua_SlotPoolT_ptr self, uint32_t size);
static void nelua_SlotPoolT_destroy(nelua_SlotPoolT_ptr self);
static uint32_t nelua_SlotPoolT_acquire_index(nelua_SlotPoolT_ptr self);
static uint32_t nelua_SlotPoolT_get_index(nelua_SlotPoolT_ptr self, uint64_t id);
typedef struct nlmulret_nluint64_nluint32 {
  uint64_t r1;
  uint32_t r2;
} nlmulret_nluint64_nluint32;
static nlmulret_nluint64_nluint32 nelua_SlotPoolT_acquire_slot(nelua_SlotPoolT_ptr self);
typedef struct nelua_ResourcePool_FStream nelua_ResourcePool_FStream;
typedef nelua_ResourcePool_FStream* nelua_ResourcePool_FStream_ptr;
struct nelua_ResourcePool_FStream {
  nelua_SlotPoolT slot_pool;
  nelua_span_FStream items;
  nelua_GeneralAllocator allocator;
};
static void nelua_grow_items(nelua_ResourcePool_FStream_ptr self);
static void nelua_ResourcePool_FStream_destroy(nelua_ResourcePool_FStream_ptr self);
static nelua_FStream_ptr nelua_ResourcePool_FStream_get(nelua_ResourcePool_FStream_ptr self, uint64_t id);
typedef struct nlmulret_nluint64_nelua_FStream_ptr {
  uint64_t r1;
  nelua_FStream_ptr r2;
} nlmulret_nluint64_nelua_FStream_ptr;
static nlmulret_nluint64_nelua_FStream_ptr nelua_ResourcePool_FStream_acquire(nelua_ResourcePool_FStream_ptr self);
static nelua_ResourcePool_FStream nelua_pool = {0};
static void nelua_destroy_pool();
typedef struct nlmulret_nlboolean_nlstring_nlint64 {
  bool r1;
  nlstring r2;
  int64_t r3;
} nlmulret_nlboolean_nlstring_nlint64;
static nlmulret_nlboolean_nlstring_nlint64 nelua_fileresult(bool success);
typedef struct nelua_filestream nelua_filestream;
struct nelua_filestream {
  uint64_t id;
};
typedef int (*function_63k29A1LdRYgBUca)(FILE_ptr);
static nelua_filestream nelua_filestream__from_fp(FILE_ptr fp, function_63k29A1LdRYgBUca closef);
typedef nelua_filestream* nelua_filestream_ptr;
static FILE_ptr nelua_filestream__get_fp(nelua_filestream_ptr self);
static nlmulret_nlboolean_nlstring_nlint64 nelua_filestream_flush(nelua_filestream_ptr self);
static nlmulret_nlboolean_nlstring_nlint64 nelua_filestream_write_1(nelua_filestream_ptr self, nlstring __arg1);
static nlmulret_nlboolean_nlstring_nlint64 nelua_filestream_writef_1(nelua_filestream_ptr self, nlstring fmt, nlstring __arg1);
static nlmulret_nlboolean_nlstring_nlint64 nelua_filestream_writef_2(nelua_filestream_ptr self, nlstring fmt, char* __arg1);
static nlmulret_nlboolean_nlstring_nlint64 nelua_filestream_writef_3(nelua_filestream_ptr self, nlstring fmt);
static nelua_filestream nelua_io_stderr = {0};
static nelua_filestream nelua_io_stdout = {0};
static nelua_filestream nelua_io_stdin = {0};
typedef va_list* nlcvalist_ptr;
static nelua_inline int nelua_C_va_arg_1(nlcvalist_ptr ap, nlniltype T);
static uint64_t forkmonhook_restart_delay = 20000U;
static uint64_t forkmonhook_ignore_delay = 200000U;
static bool forkmonhook_initialized = false;
static bool forkmonhook_handling_signal = false;
static bool forkmonhook_quiet = false;
static bool forkmonhook_no_colors = false;
static int forkmonhook_parent_inotify_fd = -1;
static int forkmonhook_child_pid = 0;
static int forkmonhook_root_pid = 0;
static uint64_t forkmonhook_last_restart_ticks = 0U;
static nelua_sequence_string forkmonhook_filter_patts = {0};
static forkmonhook_hashmap_stringboolean forkmonhook_tracked_files = {0};
typedef FILE_ptr (*forkmonhook_FopenFunc)(char*, char*);
static forkmonhook_FopenFunc forkmonhook_orig_fopen = NULL;
static forkmonhook_FopenFunc forkmonhook_orig_fopen64 = NULL;
typedef int (*forkmonhook_OpenFunc)(char*, int, int);
static forkmonhook_OpenFunc forkmonhook_orig_open = NULL;
static void forkmonhook_kill(int code);
static void forkmonhook_logf_1(nlstring fmt, nlstring __arg1);
static void forkmonhook_logf_2(nlstring fmt, char* __arg1);
static void forkmonhook_errorf_1(nlstring fmt);
static void forkmonhook_assertkill(bool cond, nlstring msg);
#define NLNIL (nlniltype){}
static bool forkmonhook_filter_filename(nlstring filename);
typedef struct nlmulret_nlcint_nlcint {
  int r1;
  int r2;
} nlmulret_nlcint_nlcint;
static nlmulret_nlcint_nlcint forkmonhook_inotify_init_watch(char* filename, int mask);
typedef struct {uint8_t data[1024];} nluint8_arr1024;
typedef struct inotify_event inotify_event;
typedef inotify_event* inotify_event_ptr;
static bool forkmonhook_monitor_file(nlstring filename);
static bool forkmonhook_track_file_open(char* name);
static void forkmonhook_signal_handler(int signum);
static char _strlit1[102] = "the environment variable FORKMON_FILTER is not set, please set one (example FORKMON_FILTER=\"%.lua$\")\n";
static void forkmonhook_parse_env();
typedef void (*function_ExBujEjR8Nqr9hSv)(int);
#ifdef _WIN32
#define nelua_cexport __declspec(dllexport) extern
#elif defined(__GNUC__)
#define nelua_cexport __attribute__((visibility ("default"))) extern
#else
#define nelua_cexport extern
#endif
nelua_cexport FILE_ptr fopen(const char* __restrict filename, const char* __restrict mode);
nelua_cexport FILE_ptr fopen64(const char* __restrict filename, const char* __restrict mode);
nelua_cexport int open(const char* __restrict path, int flags, ...);
typedef char** nlcstring_ptr;
static int nelua_main(int argc, nlcstring_ptr argv);
__attribute__((constructor)) void setup();
/* ------------------------------ DEFINITIONS ------------------------------- */
void sys_usleep(uint64_t ms) {
  timespec ts = {0};
  ts.tv_sec = (long)(ms / 1000000);
  ts.tv_nsec = (long)((ms % 1000000) * 1000);
  nanosleep((&ts), NULL);
}
uint64_t sys_uticks() {
  timespec ts = {0};
  clock_gettime(1, (&ts));
  return (uint64_t)((ts.tv_sec * 1000000) + (ts.tv_nsec / 1000));
}
int sys_killwait(int pid, int sig) {
  kill(pid, sig);
  return waitpid(pid, NULL, 0);
}
bool sys_filexists(char* path) {
  return (access(path, 0) == 0);
}
void nelua_memory_copy(void* dest, void* src, uintptr_t n) {
  memcpy(dest, src, (size_t)n);
}
int32_t nelua_memory_compare(void* a, void* b, uintptr_t n) {
  return (int32_t)memcmp(a, b, (size_t)n);
}
bool nelua_memory_equals(void* a, void* b, uintptr_t size) {
  return (memcmp(a, b, (size_t)size) == 0);
}
void* nelua_memory_find(void* haystack, uintptr_t haystacksize, void* needle, uintptr_t needlesize) {
  if(nelua_unlikely(((needlesize == 0) || (haystack == needle)))) {
    return haystack;
  } else if(nelua_unlikely((needlesize > haystacksize))) {
    return NULL;
  } else {
    if(needlesize == 1) {
      return memchr(haystack, (int)(*(nluint8_ptr)needle), (size_t)haystacksize);
    }
    uintptr_t haystackbegin = (uintptr_t)haystack;
    for(uintptr_t i = haystackbegin, _end = (haystackbegin + (haystacksize - needlesize)); i <= _end; i = i + 1) {
      void* p = (void*)i;
      if(memcmp(p, needle, (size_t)needlesize) == 0) {
        return p;
      }
    }
    return NULL;
  }
}
nlmulret_nlboolean_nlint64_nlstring nelua_ipairs_next(nelua_sequence_string a_1, int64_t k) {
  k = (k + 1);
  if(k >= (nelua_sequence_string___len(&a_1) + 1)) {
    return (nlmulret_nlboolean_nlint64_nlstring){false, 0, (nlstring){0}};
  }
  return (nlmulret_nlboolean_nlint64_nlstring){true, k, (*nelua_sequence_string___atindex(&a_1, (uintptr_t)k))};
}
nlmulret_function_LVr5rP9wJyrc2Fjq_nelua_sequence_string_nlint64 nelua_ipairs_1(nelua_sequence_string a) {
  return (nlmulret_function_LVr5rP9wJyrc2Fjq_nelua_sequence_string_nlint64){nelua_ipairs_next, a, 0};
}
nluint8_ptr nelua_span_uint8___atindex(nelua_span_uint8_ptr self, uintptr_t i) {
  return (&(self->data)[i]);
}
nlstring_ptr nelua_span_string___atindex(nelua_span_string_ptr self, uintptr_t i) {
  return (&(self->data)[i]);
}
nluint32_ptr nelua_span_uint32___atindex(nelua_span_uint32_ptr self, uintptr_t i) {
  return (&(self->data)[i]);
}
nelua_FStream_ptr nelua_span_FStream___atindex(nelua_span_FStream_ptr self, uintptr_t i) {
  return (&(self->data)[i]);
}
nlusize_ptr forkmonhook_span_usize___atindex(forkmonhook_span_usize_ptr self, uintptr_t i) {
  return (&(self->data)[i]);
}
forkmonhook_hashmap_node_nil_ptr forkmonhook_span_hashmap_node_nil___atindex(forkmonhook_span_hashmap_node_nil_ptr self, uintptr_t i) {
  return (&(self->data)[i]);
}
void nelua_memory_spanset_1(forkmonhook_span_usize dest, uintptr_t x) {
  for(uintptr_t i = 0U, _end = dest.size; i < _end; i = i + 1) {
    memcpy((void*)(&(*forkmonhook_span_usize___atindex(&dest, i))), (void*)(&x), 8U);
  }
}
bool nelua_PatternMatcherCapture_is_unfinished(nelua_PatternMatcherCapture_ptr self) {
  return (self->len == -1);
}
bool nelua_PatternMatcherCapture_is_position(nelua_PatternMatcherCapture_ptr self) {
  return (self->len == -2);
}
nelua_PatternMatcher nelua_PatternMatcher_create(nlstring source, nlstring pattern) {
  return (nelua_PatternMatcher){.source = source, .pattern = pattern, .depth = 32};
}
void nelua_abort() {
  fflush(stderr);
  abort();
}
void _nelua_assert_line1(bool cond, nlstring msg) {
  if(nelua_unlikely(!cond)) {
    fwrite("/home/bart/projects/nelua/nelua-lang/lib/patternmatcher.nelua:58:10: runtime error: ", 1, 84, stderr);
    fwrite(msg.data, msg.size, 1, stderr);
    fwrite("\n  assert(not self.capture[i]:is_position(), 'position capture not supported yet')\n         ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n", 1, 126, stderr);
    nelua_abort();
  }
}
void _nelua_assert_line2(bool cond, nlstring msg) {
  if(nelua_unlikely(!cond)) {
    fwrite("/home/bart/projects/nelua/nelua-lang/lib/patternmatcher.nelua:59:10: runtime error: ", 1, 84, stderr);
    fwrite(msg.data, msg.size, 1, stderr);
    fwrite("\n  assert(not self.capture[i]:is_unfinished(), 'unfinished capture')\n         ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n", 1, 114, stderr);
    nelua_abort();
  }
}
nlstring nelua_PatternMatcher_get_capture(nelua_PatternMatcher_ptr self, intptr_t i) {
  _nelua_assert_line1((!nelua_PatternMatcherCapture_is_position(&self->capture[i])), ((nlstring){(uint8_t*)"position capture not supported yet", 34}));
  _nelua_assert_line2((!nelua_PatternMatcherCapture_is_unfinished(&self->capture[i])), ((nlstring){(uint8_t*)"unfinished capture", 18}));
  return (nlstring){.data = ((nluint8_arr0_ptr)(&(self->source.data)[self->capture[i].init])), .size = (uintptr_t)self->capture[i].len};
}
bool nelua_match_class(uint8_t c, uint8_t cl) {
  bool res = false;
  switch(tolower((int)cl)) {
    case 97U: {
      res = (isalpha((int)c) != 0);
      break;
    }
    case 99U: {
      res = (iscntrl((int)c) != 0);
      break;
    }
    case 100U: {
      res = (isdigit((int)c) != 0);
      break;
    }
    case 103U: {
      res = (isgraph((int)c) != 0);
      break;
    }
    case 108U: {
      res = (islower((int)c) != 0);
      break;
    }
    case 112U: {
      res = (ispunct((int)c) != 0);
      break;
    }
    case 115U: {
      res = (isspace((int)c) != 0);
      break;
    }
    case 117U: {
      res = (isupper((int)c) != 0);
      break;
    }
    case 119U: {
      res = (isalnum((int)c) != 0);
      break;
    }
    case 120U: {
      res = (isxdigit((int)c) != 0);
      break;
    }
    case 122U: {
      res = (c == 0);
      break;
    }
    default: {
      return (cl == c);
      break;
    }
  }
  if(islower((int)cl) == 0) {
    res = (!res);
  }
  return res;
}
void _nelua_assert_line3(bool cond, nlstring msg) {
  if(nelua_unlikely(!cond)) {
    fwrite("/home/bart/projects/nelua/nelua-lang/lib/patternmatcher.nelua:95:14: runtime error: ", 1, 84, stderr);
    fwrite(msg.data, msg.size, 1, stderr);
    fwrite("\n      assert(p ~= #ms.pattern, \"malformed pattern (ends with '%')\")\n             ^~~~~~~~~~~~~~~~\n", 1, 99, stderr);
    nelua_abort();
  }
}
void _nelua_assert_line4(bool cond, nlstring msg) {
  if(nelua_unlikely(!cond)) {
    fwrite("/home/bart/projects/nelua/nelua-lang/lib/patternmatcher.nelua:102:16: runtime error: ", 1, 85, stderr);
    fwrite(msg.data, msg.size, 1, stderr);
    fwrite("\n        assert(p ~= #ms.pattern, \"malformed pattern (missing ']')\")\n               ^~~~~~~~~~~~~~~~\n", 1, 101, stderr);
    nelua_abort();
  }
}
intptr_t nelua_match_class_end(nelua_PatternMatcher_ptr ms_1, intptr_t p_1) {
  uint8_t c = (ms_1->pattern.data)[p_1];
  p_1 = (p_1 + 1);
  switch(c) {
    case 37U: {
      _nelua_assert_line3((p_1 != (((intptr_t)(ms_1->pattern).size))), ((nlstring){(uint8_t*)"malformed pattern (ends with '%')", 33}));
      p_1 = (p_1 + 1);
      break;
    }
    case 91U: {
      if((ms_1->pattern.data)[p_1] == 94U) {
        p_1 = (p_1 + 1);
      }
      while(1) {
        _nelua_assert_line4((p_1 != (((intptr_t)(ms_1->pattern).size))), ((nlstring){(uint8_t*)"malformed pattern (missing ']')", 31}));
        c = (ms_1->pattern.data)[p_1];
        p_1 = (p_1 + 1);
        if((c == 37U) && (p_1 < (((intptr_t)(ms_1->pattern).size)))) {
          p_1 = (p_1 + 1);
        }
        if((ms_1->pattern.data)[p_1] == 93U) {
          break;
        }
      }
      p_1 = (p_1 + 1);
      break;
    }
  }
  return p_1;
}
bool nelua_match_bracket_class(nelua_PatternMatcher_ptr ms_2, uint8_t c, intptr_t p_2, intptr_t ep) {
  bool sig = true;
  if((ms_2->pattern.data)[(p_2 + 1)] == 94U) {
    sig = false;
    p_2 = (p_2 + 1);
  }
  p_2 = (p_2 + 1);
  while(p_2 < ep) {
    if((ms_2->pattern.data)[p_2] == 37U) {
      p_2 = (p_2 + 1);
      if(nelua_match_class(c, (ms_2->pattern.data)[p_2])) {
        return sig;
      }
    } else if(((ms_2->pattern.data)[(p_2 + 1)] == 45U) && ((p_2 + 2) < ep)) {
      p_2 = (p_2 + 2);
      if(((ms_2->pattern.data)[(p_2 - 2)] <= c) && (c <= (ms_2->pattern.data)[p_2])) {
        return sig;
      }
    } else if((ms_2->pattern.data)[p_2] == c) {
      return sig;
    }
    p_2 = (p_2 + 1);
  }
  return (!sig);
}
bool nelua_match_single(nelua_PatternMatcher_ptr ms_3, intptr_t s_1, intptr_t p_3, intptr_t ep) {
  if(s_1 >= (((intptr_t)(ms_3->source).size))) {
    return false;
  } else {
    uint8_t c = (ms_3->source.data)[s_1];
    uint8_t pc = (ms_3->pattern.data)[p_3];
    switch(pc) {
      case 46U: {
        return true;
        break;
      }
      case 37U: {
        return nelua_match_class(c, (ms_3->pattern.data)[(p_3 + 1)]);
        break;
      }
      case 91U: {
        return nelua_match_bracket_class(ms_3, c, p_3, (ep - 1));
        break;
      }
      default: {
        return (pc == c);
        break;
      }
    }
  }
}
void _nelua_assert_line5(bool cond, nlstring msg) {
  if(nelua_unlikely(!cond)) {
    fwrite("/home/bart/projects/nelua/nelua-lang/lib/patternmatcher.nelua:156:12: runtime error: ", 1, 85, stderr);
    fwrite(msg.data, msg.size, 1, stderr);
    fwrite("\n    assert(p < #ms.pattern - 1, \"malformed pattern (missing arguments to '%b')\")\n           ^~~~~~~~~~~~~~~~~~~\n", 1, 113, stderr);
    nelua_abort();
  }
}
intptr_t nelua_match_balance(nelua_PatternMatcher_ptr ms_4, intptr_t s_2, intptr_t p_4) {
  _nelua_assert_line5((p_4 < ((((intptr_t)(ms_4->pattern).size)) - 1)), ((nlstring){(uint8_t*)"malformed pattern (missing arguments to '%b')", 45}));
  if((ms_4->source.data)[s_2] != (ms_4->pattern.data)[p_4]) {
    return -1;
  } else {
    uint8_t b = (ms_4->pattern.data)[p_4];
    uint8_t e = (ms_4->pattern.data)[(p_4 + 1)];
    intptr_t cont = 1;
    s_2 = (s_2 + 1);
    while(s_2 < (((intptr_t)(ms_4->source).size))) {
      if((ms_4->source.data)[s_2] == e) {
        cont = (cont - 1);
        if(cont == 0) {
          return (s_2 + 1);
        }
      } else if((ms_4->source.data)[s_2] == b) {
        cont = (cont + 1);
      }
      s_2 = (s_2 + 1);
    }
  }
  return -1;
}
intptr_t nelua_match_max_expand(nelua_PatternMatcher_ptr ms_5, intptr_t s_3, intptr_t p_5, intptr_t ep) {
  intptr_t i = 0;
  while(nelua_match_single(ms_5, (s_3 + i), p_5, ep)) {
    i = (i + 1);
  }
  while(i >= 0) {
    intptr_t res = nelua_PatternMatcher__match(ms_5, (s_3 + i), (ep + 1));
    if(res != -1) {
      return res;
    } else {
      i = (i - 1);
    }
  }
  return -1;
}
intptr_t nelua_match_min_expand(nelua_PatternMatcher_ptr ms_6, intptr_t s_4, intptr_t p_6, intptr_t ep) {
  while(true) {
    intptr_t res = nelua_PatternMatcher__match(ms_6, s_4, (ep + 1));
    if(res != -1) {
      return res;
    } else if(nelua_match_single(ms_6, s_4, p_6, ep)) {
      s_4 = (s_4 + 1);
    } else {
      return -1;
    }
  }
  return -1;
}
void _nelua_assert_line6(bool cond, nlstring msg) {
  if(nelua_unlikely(!cond)) {
    fwrite("/home/bart/projects/nelua/nelua-lang/lib/patternmatcher.nelua:211:12: runtime error: ", 1, 85, stderr);
    fwrite(msg.data, msg.size, 1, stderr);
    fwrite("\n    assert(numcaptures < #ms.capture, \"too many captures\")\n           ^~~~~~~~~~~~~~~~~~~~~~~~~\n", 1, 97, stderr);
    nelua_abort();
  }
}
intptr_t nelua_match_start_capture(nelua_PatternMatcher_ptr ms_7, intptr_t s_5, intptr_t p_7, intptr_t what) {
  intptr_t numcaptures = ms_7->numcaptures;
  _nelua_assert_line6((numcaptures < 32), ((nlstring){(uint8_t*)"too many captures", 17}));
  ms_7->capture[numcaptures].init = s_5;
  ms_7->capture[numcaptures].len = what;
  ms_7->numcaptures = (numcaptures + 1);
  intptr_t res = nelua_PatternMatcher__match(ms_7, s_5, p_7);
  if(res == -1) {
    ms_7->numcaptures = (ms_7->numcaptures - 1);
  }
  return res;
}
void _nelua_assert_line7(bool cond, nlstring msg) {
  if(nelua_unlikely(!cond)) {
    fwrite("/home/bart/projects/nelua/nelua-lang/lib/patternmatcher.nelua:230:12: runtime error: ", 1, 85, stderr);
    fwrite(msg.data, msg.size, 1, stderr);
    fwrite("\n    assert(l ~= -1, \"invalid pattern capture\")\n           ^~~~~~~\n", 1, 67, stderr);
    nelua_abort();
  }
}
intptr_t nelua_match_end_capture(nelua_PatternMatcher_ptr ms_8, intptr_t s_6, intptr_t p_8) {
  intptr_t l = -1;
  for(intptr_t numcaptures = (ms_8->numcaptures - 1); numcaptures >= 0; numcaptures = numcaptures + -1) {
    if(ms_8->capture[numcaptures].len == -1) {
      l = numcaptures;
      break;
    }
  }
  _nelua_assert_line7((l != -1), ((nlstring){(uint8_t*)"invalid pattern capture", 23}));
  ms_8->capture[l].len = (s_6 - ms_8->capture[l].init);
  intptr_t res = nelua_PatternMatcher__match(ms_8, s_6, p_8);
  if(res == -1) {
    ms_8->capture[l].len = -1;
  }
  return res;
}
void _nelua_assert_line8(bool cond, nlstring msg) {
  if(nelua_unlikely(!cond)) {
    fwrite("/home/bart/projects/nelua/nelua-lang/lib/patternmatcher.nelua:241:12: runtime error: ", 1, 85, stderr);
    fwrite(msg.data, msg.size, 1, stderr);
    fwrite("\n    assert(l >= 0 and (@isize)(l) < ms.numcaptures and ms.capture[l].len ~= CAP_UNFINISHED, \"invalid capture index\")\n           ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n", 1, 209, stderr);
    nelua_abort();
  }
}
intptr_t nelua_match_capture(nelua_PatternMatcher_ptr ms_9, intptr_t s_7, uint8_t l) {
  l = (l - 49U);
  _nelua_assert_line8((((l >= 0) && ((intptr_t)l < ms_9->numcaptures)) && (ms_9->capture[l].len != -1)), ((nlstring){(uint8_t*)"invalid capture index", 21}));
  uintptr_t len = (uintptr_t)ms_9->capture[l].len;
  if(((uintptr_t)((((intptr_t)(ms_9->source).size)) - s_7) >= len) && (nelua_memory_compare((void*)(&(ms_9->source.data)[ms_9->capture[l].init]), (void*)(&(ms_9->source.data)[s_7]), len) == 0)) {
    return (intptr_t)((int64_t)(s_7 + len));
  }
  return -1;
}
void _nelua_assert_line9(bool cond, nlstring msg) {
  if(nelua_unlikely(!cond)) {
    fwrite("/home/bart/projects/nelua/nelua-lang/lib/patternmatcher.nelua:251:10: runtime error: ", 1, 85, stderr);
    fwrite(msg.data, msg.size, 1, stderr);
    fwrite("\n  assert(ms.depth > 0, 'pattern too complex')\n         ^~~~~~~~~~~~\n", 1, 69, stderr);
    nelua_abort();
  }
}
void _nelua_assert_line10(bool cond, nlstring msg) {
  if(nelua_unlikely(!cond)) {
    fwrite("/home/bart/projects/nelua/nelua-lang/lib/patternmatcher.nelua:281:16: runtime error: ", 1, 85, stderr);
    fwrite(msg.data, msg.size, 1, stderr);
    fwrite("\n        assert(ms.pattern.data[p] == '['_byte, \"missing '[' after '%f' in pattern\")\n               ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n", 1, 131, stderr);
    nelua_abort();
  }
}
intptr_t nelua_PatternMatcher__match(nelua_PatternMatcher_ptr ms, intptr_t s, intptr_t p) {
  ms->depth = (ms->depth - 1);
  _nelua_assert_line9((ms->depth > 0), ((nlstring){(uint8_t*)"pattern too complex", 19}));
nelua_init:;
  if(p < (((intptr_t)(ms->pattern).size))) {
    switch((ms->pattern.data)[p]) {
      case 40U: {
        if((ms->pattern.data)[(p + 1)] == 41U) {
          s = nelua_match_start_capture(ms, s, (p + 2), -2);
        } else {
          s = nelua_match_start_capture(ms, s, (p + 1), -1);
        }
        break;
      }
      case 41U: {
        s = nelua_match_end_capture(ms, s, (p + 1));
        break;
      }
      case 36U: {
        if((p + 1) != (((intptr_t)(ms->pattern).size))) {
          goto nelua_dflt;
        }
        if(s != (((intptr_t)(ms->source).size))) {
          s = -1;
        }
        break;
      }
      case 37U: {
        switch((ms->pattern.data)[(p + 1)]) {
          case 98U: {
            s = nelua_match_balance(ms, s, (p + 2));
            if(s != -1) {
              p = (p + 4);
              goto nelua_init;
            }
            break;
          }
          case 102U: {
            p = (p + 2);
            _nelua_assert_line10(((ms->pattern.data)[p] == 91U), ((nlstring){(uint8_t*)"missing '[' after '%f' in pattern", 33}));
            intptr_t ep = nelua_match_class_end(ms, p);
            uint8_t previous = ((s == 0) ? 0U : (ms->source.data)[(s - 1)]);
            if((!nelua_match_bracket_class(ms, previous, p, (ep - 1))) && nelua_match_bracket_class(ms, (ms->source.data)[s], p, (ep - 1))) {
              p = ep;
              goto nelua_init;
            }
            s = -1;
            break;
          }
          case 48U:
          case 49U:
          case 50U:
          case 51U:
          case 52U:
          case 53U:
          case 54U:
          case 55U:
          case 56U:
          case 57U: {
            s = nelua_match_capture(ms, s, (ms->pattern.data)[(p + 1)]);
            if(s != -1) {
              p = (p + 2);
              goto nelua_init;
            }
            break;
          }
          default: {
            goto nelua_dflt;
            break;
          }
        }
        break;
      }
      default: {
        goto nelua_dflt;
        break;
      }
    }
    goto nelua_out;
nelua_dflt:;
    {
      intptr_t ep = nelua_match_class_end(ms, p);
      uint8_t epc = (ms->pattern.data)[ep];
      if(!nelua_match_single(ms, s, p, ep)) {
        if(((epc == 42U) || (epc == 63U)) || (epc == 45U)) {
          p = (ep + 1);
          goto nelua_init;
        } else {
          s = -1;
        }
      } else {
        switch(epc) {
          case 63U: {
            intptr_t res = nelua_PatternMatcher__match(ms, (s + 1), (ep + 1));
            if(res != -1) {
              s = res;
            } else {
              p = (ep + 1);
              goto nelua_init;
            }
            break;
          }
          case 43U: {
            s = (s + 1);
            s = nelua_match_max_expand(ms, s, p, ep);
            break;
          }
          case 42U: {
            s = nelua_match_max_expand(ms, s, p, ep);
            break;
          }
          case 45U: {
            s = nelua_match_min_expand(ms, s, p, ep);
            break;
          }
          default: {
            s = (s + 1);
            p = ep;
            goto nelua_init;
            break;
          }
        }
      }
    }
  }
nelua_out:;
  ms->depth = (ms->depth + 1);
  return s;
}
bool nelua_match_has_pattern_specials(nlstring pattern) {
  for(uintptr_t i = 0U, _end = pattern.size; i < _end; i = i + 1) {
    switch((pattern.data)[i]) {
      case 94U:
      case 36U:
      case 42U:
      case 43U:
      case 63U:
      case 46U:
      case 40U:
      case 91U:
      case 37U:
      case 45U: {
        return true;
        break;
      }
    }
  }
  return false;
}
nlmulret_nlisize_nlisize nelua_PatternMatcher_match(nelua_PatternMatcher_ptr ms, intptr_t init, bool plain) {
  if(init < 0) {
    init = (((intptr_t)ms->source.size + init) + 1);
  }
  if(init <= 0) {
    init = 1;
  }
  intptr_t s = (init - 1);
  if((uintptr_t)s > ms->source.size) {
    return (nlmulret_nlisize_nlisize){s, -1};
  } else if(ms->pattern.size == 0) {
    return (nlmulret_nlisize_nlisize){s, s};
  } else if(plain || (!nelua_match_has_pattern_specials(ms->pattern))) {
    void* found = nelua_memory_find((void*)(&(ms->source.data)[s]), (ms->source.size - (uintptr_t)s), (void*)(&(ms->pattern.data)[0]), ms->pattern.size);
    if(!(found != NULL)) {
      return (nlmulret_nlisize_nlisize){s, -1};
    } else {
      s = (intptr_t)((uintptr_t)found - (uintptr_t)(&(ms->source.data)[0]));
      return (nlmulret_nlisize_nlisize){s, (intptr_t)((int64_t)(s + ms->pattern.size))};
    }
  } else {
    intptr_t p = 0;
    bool anchor = ((ms->pattern.data)[0] == 94U);
    if(anchor) {
      p = 1;
    }
    while(1) {
      ms->numcaptures = 0;
      intptr_t e = nelua_PatternMatcher__match(ms, s, p);
      if(e != -1) {
        return (nlmulret_nlisize_nlisize){s, e};
      }
      s = (s + 1);
      if((s >= (((intptr_t)(ms->source).size))) || anchor) {
        break;
      }
    }
    return (nlmulret_nlisize_nlisize){s, -1};
  }
}
void nelua_sequence_string__grow(nelua_sequence_string_ptr self) {
  uintptr_t cap = (uintptr_t)2U;
  if(nelua_likely((self->impl->data.size != 0))) {
    cap = (self->impl->data.size * 2);
  }
  self->impl->data = nelua_GeneralAllocator_spanxrealloc0_1(&self->allocator, self->impl->data, cap);
}
void nelua_sequence_string_init(nelua_sequence_string_ptr self) {
  if(nelua_likely((self->impl != NULL))) {
    return;
  }
  self->impl = ((nelua_sequenceimpl_string_ptr)nelua_GeneralAllocator_xalloc0(&self->allocator, 24U));
}
nlstring_ptr nelua_sequence_string___atindex(nelua_sequence_string_ptr self, uintptr_t i) {
  nelua_sequence_string_init(self);
  if(nelua_unlikely((i > self->impl->size))) {
    self->impl->size = (self->impl->size + 1);
  }
  if(nelua_unlikely(((self->impl->size + 1) > self->impl->data.size))) {
    nelua_sequence_string__grow(self);
  }
  return (&(*nelua_span_string___atindex(&self->impl->data, i)));
}
intptr_t nelua_sequence_string___len(nelua_sequence_string_ptr self) {
  if(nelua_unlikely((!(self->impl != NULL)))) {
    return 0;
  }
  return (intptr_t)self->impl->size;
}
void* nelua_GeneralAllocator_alloc(nelua_GeneralAllocator_ptr self, uintptr_t size) {
  if(nelua_unlikely((size == 0))) {
    return NULL;
  }
  return malloc((size_t)size);
}
void* nelua_GeneralAllocator_alloc0(nelua_GeneralAllocator_ptr self, uintptr_t size) {
  if(nelua_unlikely((size == 0))) {
    return NULL;
  }
  return calloc((size_t)size, (size_t)1U);
}
void* nelua_GeneralAllocator_realloc(nelua_GeneralAllocator_ptr self, void* p, uintptr_t newsize, uintptr_t oldsize) {
  if(nelua_unlikely((newsize == 0))) {
    if(nelua_likely((p != NULL))) {
      free(p);
    }
    return NULL;
  } else if(nelua_unlikely((newsize == oldsize))) {
    return p;
  }
  return realloc(p, (size_t)newsize);
}
void nelua_GeneralAllocator_dealloc(nelua_GeneralAllocator_ptr self, void* p) {
  if(nelua_unlikely((p == NULL))) {
    return;
  }
  free(p);
}
void* nelua_GeneralAllocator_realloc0(nelua_GeneralAllocator_ptr self, void* p, uintptr_t newsize, uintptr_t oldsize) {
  p = nelua_GeneralAllocator_realloc(self, p, newsize, oldsize);
  if(nelua_likely(((newsize > oldsize) && (p != NULL)))) {
    memset((void*)(&(((nluint8_arr0_ptr)p))[oldsize]), 0, (size_t)(newsize - oldsize));
  }
  return p;
}
forkmonhook_span_usize nelua_GeneralAllocator_spanrealloc_2(nelua_GeneralAllocator_ptr self, forkmonhook_span_usize s, uintptr_t size) {
  nlusize_arr0_ptr p = ((nlusize_arr0_ptr)nelua_GeneralAllocator_realloc(self, (void*)s.data, (size * 8), s.size));
  if(nelua_unlikely(((size > 0) && (p == NULL)))) {
    return s;
  }
  s.data = p;
  s.size = size;
  return s;
}
nelua_span_uint8 nelua_GeneralAllocator_spanrealloc0_1(nelua_GeneralAllocator_ptr self, nelua_span_uint8 s, uintptr_t size) {
  nluint8_arr0_ptr p = ((nluint8_arr0_ptr)nelua_GeneralAllocator_realloc0(self, (void*)s.data, (size * 1), (s.size * 1)));
  if(nelua_unlikely(((size > 0) && (p == NULL)))) {
    return s;
  }
  s.data = p;
  s.size = size;
  return s;
}
nelua_span_string nelua_GeneralAllocator_spanrealloc0_2(nelua_GeneralAllocator_ptr self, nelua_span_string s, uintptr_t size) {
  nlstring_arr0_ptr p = ((nlstring_arr0_ptr)nelua_GeneralAllocator_realloc0(self, (void*)s.data, (size * 16), (s.size * 16)));
  if(nelua_unlikely(((size > 0) && (p == NULL)))) {
    return s;
  }
  s.data = p;
  s.size = size;
  return s;
}
nelua_span_uint32 nelua_GeneralAllocator_spanrealloc0_3(nelua_GeneralAllocator_ptr self, nelua_span_uint32 s, uintptr_t size) {
  nluint32_arr0_ptr p = ((nluint32_arr0_ptr)nelua_GeneralAllocator_realloc0(self, (void*)s.data, (size * 4), (s.size * 4)));
  if(nelua_unlikely(((size > 0) && (p == NULL)))) {
    return s;
  }
  s.data = p;
  s.size = size;
  return s;
}
nelua_span_FStream nelua_GeneralAllocator_spanrealloc0_4(nelua_GeneralAllocator_ptr self, nelua_span_FStream s, uintptr_t size) {
  nelua_FStream_arr0_ptr p = ((nelua_FStream_arr0_ptr)nelua_GeneralAllocator_realloc0(self, (void*)s.data, (size * 16), (s.size * 16)));
  if(nelua_unlikely(((size > 0) && (p == NULL)))) {
    return s;
  }
  s.data = p;
  s.size = size;
  return s;
}
forkmonhook_span_hashmap_node_nil nelua_GeneralAllocator_spanrealloc0_5(nelua_GeneralAllocator_ptr self, forkmonhook_span_hashmap_node_nil s, uintptr_t size) {
  forkmonhook_hashmap_node_nil_arr0_ptr p = ((forkmonhook_hashmap_node_nil_arr0_ptr)nelua_GeneralAllocator_realloc0(self, (void*)s.data, (size * 32), (s.size * 32)));
  if(nelua_unlikely(((size > 0) && (p == NULL)))) {
    return s;
  }
  s.data = p;
  s.size = size;
  return s;
}
void nelua_GeneralAllocator_spandealloc_1(nelua_GeneralAllocator_ptr self, nelua_span_uint8 s) {
  if(nelua_unlikely((s.size == 0))) {
    return;
  }
  nelua_GeneralAllocator_dealloc(self, (void*)s.data);
}
void nelua_GeneralAllocator_spandealloc_3(nelua_GeneralAllocator_ptr self, nelua_span_uint32 s) {
  if(nelua_unlikely((s.size == 0))) {
    return;
  }
  nelua_GeneralAllocator_dealloc(self, (void*)s.data);
}
void nelua_GeneralAllocator_spandealloc_4(nelua_GeneralAllocator_ptr self, nelua_span_FStream s) {
  if(nelua_unlikely((s.size == 0))) {
    return;
  }
  nelua_GeneralAllocator_dealloc(self, (void*)s.data);
}
void _nelua_assert_line11(bool cond, nlstring msg) {
  if(nelua_unlikely(!cond)) {
    fwrite("/home/bart/projects/nelua/nelua-lang/lib/allocators/interface.nelua:182:12: runtime error: ", 1, 91, stderr);
    fwrite(msg.data, msg.size, 1, stderr);
    fwrite("\n    assert(p ~= nilptr, 'out of memory')\n           ^~~~~~~~~~~\n", 1, 65, stderr);
    nelua_abort();
  }
}
void* nelua_GeneralAllocator_xalloc(nelua_GeneralAllocator_ptr self, uintptr_t size) {
  void* p = nelua_GeneralAllocator_alloc(self, size);
  _nelua_assert_line11((p != NULL), ((nlstring){(uint8_t*)"out of memory", 13}));
  return p;
}
void _nelua_assert_line12(bool cond, nlstring msg) {
  if(nelua_unlikely(!cond)) {
    fwrite("/home/bart/projects/nelua/nelua-lang/lib/allocators/interface.nelua:188:12: runtime error: ", 1, 91, stderr);
    fwrite(msg.data, msg.size, 1, stderr);
    fwrite("\n    assert(p ~= nilptr, 'out of memory')\n           ^~~~~~~~~~~\n", 1, 65, stderr);
    nelua_abort();
  }
}
void* nelua_GeneralAllocator_xalloc0(nelua_GeneralAllocator_ptr self, uintptr_t size) {
  void* p = nelua_GeneralAllocator_alloc0(self, size);
  _nelua_assert_line12((p != NULL), ((nlstring){(uint8_t*)"out of memory", 13}));
  return p;
}
void _nelua_assert_line13(bool cond, nlstring msg) {
  if(nelua_unlikely(!cond)) {
    fwrite("/home/bart/projects/nelua/nelua-lang/lib/allocators/interface.nelua:218:12: runtime error: ", 1, 91, stderr);
    fwrite(msg.data, msg.size, 1, stderr);
    fwrite("\n    assert(s.size == size, 'out of memory')\n           ^~~~~~~~~~~~~~\n", 1, 71, stderr);
    nelua_abort();
  }
}
forkmonhook_span_usize nelua_GeneralAllocator_spanxrealloc_2(nelua_GeneralAllocator_ptr self, forkmonhook_span_usize s, uintptr_t size) {
  s = nelua_GeneralAllocator_spanrealloc_2(self, s, size);
  _nelua_assert_line13((s.size == size), ((nlstring){(uint8_t*)"out of memory", 13}));
  return s;
}
void _nelua_assert_line14(bool cond, nlstring msg) {
  if(nelua_unlikely(!cond)) {
    fwrite("/home/bart/projects/nelua/nelua-lang/lib/allocators/interface.nelua:224:12: runtime error: ", 1, 91, stderr);
    fwrite(msg.data, msg.size, 1, stderr);
    fwrite("\n    assert(s.size == size, 'out of memory')\n           ^~~~~~~~~~~~~~\n", 1, 71, stderr);
    nelua_abort();
  }
}
nelua_span_string nelua_GeneralAllocator_spanxrealloc0_1(nelua_GeneralAllocator_ptr self, nelua_span_string s, uintptr_t size) {
  s = nelua_GeneralAllocator_spanrealloc0_2(self, s, size);
  _nelua_assert_line14((s.size == size), ((nlstring){(uint8_t*)"out of memory", 13}));
  return s;
}
void _nelua_assert_line15(bool cond, nlstring msg) {
  if(nelua_unlikely(!cond)) {
    fwrite("/home/bart/projects/nelua/nelua-lang/lib/allocators/interface.nelua:224:12: runtime error: ", 1, 91, stderr);
    fwrite(msg.data, msg.size, 1, stderr);
    fwrite("\n    assert(s.size == size, 'out of memory')\n           ^~~~~~~~~~~~~~\n", 1, 71, stderr);
    nelua_abort();
  }
}
nelua_span_uint32 nelua_GeneralAllocator_spanxrealloc0_2(nelua_GeneralAllocator_ptr self, nelua_span_uint32 s, uintptr_t size) {
  s = nelua_GeneralAllocator_spanrealloc0_3(self, s, size);
  _nelua_assert_line15((s.size == size), ((nlstring){(uint8_t*)"out of memory", 13}));
  return s;
}
void _nelua_assert_line16(bool cond, nlstring msg) {
  if(nelua_unlikely(!cond)) {
    fwrite("/home/bart/projects/nelua/nelua-lang/lib/allocators/interface.nelua:224:12: runtime error: ", 1, 91, stderr);
    fwrite(msg.data, msg.size, 1, stderr);
    fwrite("\n    assert(s.size == size, 'out of memory')\n           ^~~~~~~~~~~~~~\n", 1, 71, stderr);
    nelua_abort();
  }
}
nelua_span_FStream nelua_GeneralAllocator_spanxrealloc0_3(nelua_GeneralAllocator_ptr self, nelua_span_FStream s, uintptr_t size) {
  s = nelua_GeneralAllocator_spanrealloc0_4(self, s, size);
  _nelua_assert_line16((s.size == size), ((nlstring){(uint8_t*)"out of memory", 13}));
  return s;
}
void _nelua_assert_line17(bool cond, nlstring msg) {
  if(nelua_unlikely(!cond)) {
    fwrite("/home/bart/projects/nelua/nelua-lang/lib/allocators/interface.nelua:224:12: runtime error: ", 1, 91, stderr);
    fwrite(msg.data, msg.size, 1, stderr);
    fwrite("\n    assert(s.size == size, 'out of memory')\n           ^~~~~~~~~~~~~~\n", 1, 71, stderr);
    nelua_abort();
  }
}
forkmonhook_span_hashmap_node_nil nelua_GeneralAllocator_spanxrealloc0_4(nelua_GeneralAllocator_ptr self, forkmonhook_span_hashmap_node_nil s, uintptr_t size) {
  s = nelua_GeneralAllocator_spanrealloc0_5(self, s, size);
  _nelua_assert_line17((s.size == size), ((nlstring){(uint8_t*)"out of memory", 13}));
  return s;
}
nlstring nelua_nlstring__create(uintptr_t size) {
  nlstring s = {0};
  s.size = size;
  s.data = ((nluint8_arr0_ptr)nelua_GeneralAllocator_xalloc(&nelua_general_allocator, (size + 1)));
  (s.data)[size] = (uint8_t)0U;
  return s;
}
char* nelua_string2cstring(nlstring s) {
  return (s.size == 0) ? "" : (char*)s.data;
}
void _nelua_assert_line18(bool cond, nlstring msg) {
  if(nelua_unlikely(!cond)) {
    fwrite("/home/bart/projects/nelua/nelua-lang/lib/stringbuilder.nelua:29:10: runtime error: ", 1, 83, stderr);
    fwrite(msg.data, msg.size, 1, stderr);
    fwrite("\n  assert(p < L_FMTFLAGS.size + 1, \"invalid format (repeated flags)\")\n         ^~~~~~~~~~~~~~~~~~~~~~~\n", 1, 103, stderr);
    nelua_abort();
  }
}
void _nelua_assert_line19(bool cond, nlstring msg) {
  if(nelua_unlikely(!cond)) {
    fwrite("/home/bart/projects/nelua/nelua-lang/lib/stringbuilder.nelua:37:10: runtime error: ", 1, 83, stderr);
    fwrite(msg.data, msg.size, 1, stderr);
    fwrite("\n  assert(isdigit(strfmt[p]) == 0, \"invalid format (width or precision too long)\")\n         ^~~~~~~~~~~~~~~~~~~~~~~\n", 1, 116, stderr);
    nelua_abort();
  }
}
uintptr_t nelua_scanformat(nluint8_arr0_ptr strfmt, nluint8_arr32_ptr form) {
  uintptr_t p = (uintptr_t)0U;
  while(((strfmt)[p] != 0) && (strchr(nelua_string2cstring(((nlstring){(uint8_t*)"-+ #0", 5})), (int)(strfmt)[p]) != NULL)) {
    p = (p + 1);
  }
  _nelua_assert_line18((p < (((nlstring){(uint8_t*)"-+ #0", 5}).size + 1)), ((nlstring){(uint8_t*)"invalid format (repeated flags)", 31}));
  if(isdigit((int)(strfmt)[p]) != 0) {
    p = (p + 1);
  }
  if(isdigit((int)(strfmt)[p]) != 0) {
    p = (p + 1);
  }
  if((strfmt)[p] == 46U) {
    p = (p + 1);
    if(isdigit((int)(strfmt)[p]) != 0) {
      p = (p + 1);
    }
    if(isdigit((int)(strfmt)[p]) != 0) {
      p = (p + 1);
    }
  }
  _nelua_assert_line19((isdigit((int)(strfmt)[p]) == 0), ((nlstring){(uint8_t*)"invalid format (width or precision too long)", 44}));
  ((uint8_t*)form)[0] = 37U;
  nelua_memory_copy((void*)(&((uint8_t*)form)[1]), (void*)(&(strfmt)[0]), (p + 1));
  ((uint8_t*)form)[(p + 2)] = (uint8_t)0U;
  return p;
}
void nelua_stringbuilderT_destroy(nelua_stringbuilderT_ptr self) {
  nelua_GeneralAllocator_spandealloc_1(&self->allocator, self->data);
  (*self) = (nelua_stringbuilderT){0};
}
nluint8_arr0_ptr nelua_stringbuilderT_prepare(nelua_stringbuilderT_ptr self, uintptr_t size) {
  uintptr_t needed = ((self->size + size) + 1);
  uintptr_t cap = self->data.size;
  if(nelua_unlikely((needed > cap))) {
    if(nelua_unlikely((cap == 0))) {
      cap = 128U;
    }
    while(1) {
      cap = (cap * 2);
      if(cap >= needed) {
        break;
      }
    }
    self->data = nelua_GeneralAllocator_spanrealloc0_1(&self->allocator, self->data, cap);
    if(nelua_unlikely((self->data.size != cap))) {
      self->data = nelua_GeneralAllocator_spanrealloc0_1(&self->allocator, self->data, needed);
      if(self->data.size != needed) {
        return NULL;
      }
    }
  }
  return ((nluint8_arr0_ptr)(&(*nelua_span_uint8___atindex(&self->data, self->size))));
}
void nelua_stringbuilderT_commit(nelua_stringbuilderT_ptr self, uintptr_t size) {
  uintptr_t newsize = (self->size + size);
  self->size = newsize;
}
bool nelua_stringbuilderT_write_byte(nelua_stringbuilderT_ptr self, uint8_t c) {
  nluint8_arr0_ptr p = nelua_stringbuilderT_prepare(self, 1U);
  if(nelua_unlikely((p == NULL))) {
    return false;
  }
  (p)[0] = c;
  self->size = (self->size + 1);
  return true;
}
void _nelua_assert_line20(bool cond, nlstring msg) {
  if(nelua_unlikely(!cond)) {
    fwrite("/home/bart/projects/nelua/nelua-lang/lib/stringbuilder.nelua:200:12: runtime error: ", 1, 84, stderr);
    fwrite(msg.data, msg.size, 1, stderr);
    fwrite("\n    assert(false, 'invalid format for argument')\n           ^~~~~\n", 1, 67, stderr);
    nelua_abort();
  }
}
void _nelua_assert_line21(bool cond, nlstring msg) {
  if(nelua_unlikely(!cond)) {
    fwrite("/home/bart/projects/nelua/nelua-lang/lib/stringbuilder.nelua:202:12: runtime error: ", 1, 84, stderr);
    fwrite(msg.data, msg.size, 1, stderr);
    fwrite("\n    assert(nb >= 0 and nb < (@isize)(maxitem), 'unexpected number of bytes written in sprintf')\n           ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n", 1, 143, stderr);
    nelua_abort();
  }
}
nlmulret_nlboolean_nlcint nelua_formatarg_2(nelua_stringbuilderT_ptr self, uint8_t c, char* buff, uintptr_t maxitem, nluint8_arr32_ptr form, nlstring arg1) {
  int nb = -1;
  if(c == 115U) {
    nlstring s = arg1;
    maxitem = (s.size + 1);
    buff = (char*)nelua_stringbuilderT_prepare(self, maxitem);
    if((buff != NULL)) {
      if((((uint8_t*)form)[1] == c) && (((uint8_t*)form)[2] == 0)) {
        nelua_memory_copy((void*)buff, (void*)s.data, s.size);
        nb = (int)s.size;
      } else {
        s = nelua_nlstring_copy(s);
        nb = snprintf(buff, (size_t)maxitem, (char*)(&((uint8_t*)form)[0]), s.data);
        nelua_nlstring_destroy(s);
      }
    }
    if(!(buff != NULL)) {
      return (nlmulret_nlboolean_nlcint){false, 0};
    }
    goto nelua_next_6;
  }
  _nelua_assert_line20(false, ((nlstring){(uint8_t*)"invalid format for argument", 27}));
nelua_next_6:;
  _nelua_assert_line21(((nb >= 0) && (nb < (intptr_t)maxitem)), ((nlstring){(uint8_t*)"unexpected number of bytes written in sprintf", 45}));
  return (nlmulret_nlboolean_nlcint){true, nb};
}
nlstring nelua_cstring2string(char* s) {
  if(s == NULL) return (nlstring){0};
  uintptr_t size = strlen(s);
  if(size == 0) return (nlstring){0};
  return (nlstring){(uint8_t*)s, size};
}
void _nelua_assert_line22(bool cond, nlstring msg) {
  if(nelua_unlikely(!cond)) {
    fwrite("/home/bart/projects/nelua/nelua-lang/lib/stringbuilder.nelua:200:12: runtime error: ", 1, 84, stderr);
    fwrite(msg.data, msg.size, 1, stderr);
    fwrite("\n    assert(false, 'invalid format for argument')\n           ^~~~~\n", 1, 67, stderr);
    nelua_abort();
  }
}
void _nelua_assert_line23(bool cond, nlstring msg) {
  if(nelua_unlikely(!cond)) {
    fwrite("/home/bart/projects/nelua/nelua-lang/lib/stringbuilder.nelua:202:12: runtime error: ", 1, 84, stderr);
    fwrite(msg.data, msg.size, 1, stderr);
    fwrite("\n    assert(nb >= 0 and nb < (@isize)(maxitem), 'unexpected number of bytes written in sprintf')\n           ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n", 1, 143, stderr);
    nelua_abort();
  }
}
nlmulret_nlboolean_nlcint nelua_formatarg_3(nelua_stringbuilderT_ptr self, uint8_t c, char* buff, uintptr_t maxitem, nluint8_arr32_ptr form, char* arg1) {
  int nb = -1;
  if(c == 112U) {
    void* p = (void*)arg1;
    if(p == NULL) {
      strcpy(buff, "(null)");
      nb = 6;
    } else {
      nb = snprintf(buff, (size_t)maxitem, (char*)(&((uint8_t*)form)[0]), p);
    }
    goto nelua_next_7;
  }
  if(c == 115U) {
    nlstring s = nelua_cstring2string(arg1);
    maxitem = (s.size + 1);
    buff = (char*)nelua_stringbuilderT_prepare(self, maxitem);
    if((buff != NULL)) {
      if((((uint8_t*)form)[1] == c) && (((uint8_t*)form)[2] == 0)) {
        nelua_memory_copy((void*)buff, (void*)s.data, s.size);
        nb = (int)s.size;
      } else {
        nb = snprintf(buff, (size_t)maxitem, (char*)(&((uint8_t*)form)[0]), s.data);
      }
    }
    if(!(buff != NULL)) {
      return (nlmulret_nlboolean_nlcint){false, 0};
    }
    goto nelua_next_7;
  }
  _nelua_assert_line22(false, ((nlstring){(uint8_t*)"invalid format for argument", 27}));
nelua_next_7:;
  _nelua_assert_line23(((nb >= 0) && (nb < (intptr_t)maxitem)), ((nlstring){(uint8_t*)"unexpected number of bytes written in sprintf", 45}));
  return (nlmulret_nlboolean_nlcint){true, nb};
}
void _nelua_assert_line24(bool cond, nlstring msg) {
  if(nelua_unlikely(!cond)) {
    fwrite("/home/bart/projects/nelua/nelua-lang/lib/stringbuilder.nelua:244:18: runtime error: ", 1, 84, stderr);
    fwrite(msg.data, msg.size, 1, stderr);
    fwrite("\n          assert(nb >= 0, 'missing argument in format')\n                 ^~~~~~~\n", 1, 82, stderr);
    nelua_abort();
  }
}
bool nelua_stringbuilderT_write_format_2(nelua_stringbuilderT_ptr self, nlstring fmt, nlstring __arg1) {
  uintptr_t pos = (uintptr_t)0U;
  int32_t argi = 0;
  while(pos < fmt.size) {
    uint8_t c = (fmt.data)[pos];
    pos = (pos + 1);
    if(c != 37U) {
      if(!nelua_stringbuilderT_write_byte(self, c)) {
        return false;
      }
    } else {
      c = (fmt.data)[pos];
      if(c == 37U) {
        if(!nelua_stringbuilderT_write_byte(self, 37U)) {
          return false;
        }
        pos = (pos + 1);
      } else {
        nluint8_arr32 form = {0};
        uintptr_t maxitem = 120U;
        char* buff = (char*)nelua_stringbuilderT_prepare(self, 120U);
        if(!(buff != NULL)) {
          return false;
        }
        pos = (pos + nelua_scanformat(((nluint8_arr0_ptr)(&(fmt.data)[pos])), (&form)));
        c = (fmt.data)[pos];
        pos = (pos + 1);
        argi = (argi + 1);
        bool ok = false;
        int nb = -1;
        if(1 == argi) {
          nlmulret_nlboolean_nlcint _ret1 = nelua_formatarg_2(self, c, buff, maxitem, (&form), __arg1);
          ok = _ret1.r1;
          nb = _ret1.r2;
          goto nelua_next_3;
        }
nelua_next_3:;
        if(!ok) {
          return false;
        }
        _nelua_assert_line24((nb >= 0), ((nlstring){(uint8_t*)"missing argument in format", 26}));
        nelua_stringbuilderT_commit(self, (uintptr_t)nb);
      }
    }
  }
  return true;
}
void _nelua_assert_line25(bool cond, nlstring msg) {
  if(nelua_unlikely(!cond)) {
    fwrite("/home/bart/projects/nelua/nelua-lang/lib/stringbuilder.nelua:244:18: runtime error: ", 1, 84, stderr);
    fwrite(msg.data, msg.size, 1, stderr);
    fwrite("\n          assert(nb >= 0, 'missing argument in format')\n                 ^~~~~~~\n", 1, 82, stderr);
    nelua_abort();
  }
}
bool nelua_stringbuilderT_write_format_3(nelua_stringbuilderT_ptr self, nlstring fmt, char* __arg1) {
  uintptr_t pos = (uintptr_t)0U;
  int32_t argi = 0;
  while(pos < fmt.size) {
    uint8_t c = (fmt.data)[pos];
    pos = (pos + 1);
    if(c != 37U) {
      if(!nelua_stringbuilderT_write_byte(self, c)) {
        return false;
      }
    } else {
      c = (fmt.data)[pos];
      if(c == 37U) {
        if(!nelua_stringbuilderT_write_byte(self, 37U)) {
          return false;
        }
        pos = (pos + 1);
      } else {
        nluint8_arr32 form = {0};
        uintptr_t maxitem = 120U;
        char* buff = (char*)nelua_stringbuilderT_prepare(self, 120U);
        if(!(buff != NULL)) {
          return false;
        }
        pos = (pos + nelua_scanformat(((nluint8_arr0_ptr)(&(fmt.data)[pos])), (&form)));
        c = (fmt.data)[pos];
        pos = (pos + 1);
        argi = (argi + 1);
        bool ok = false;
        int nb = -1;
        if(1 == argi) {
          nlmulret_nlboolean_nlcint _ret2 = nelua_formatarg_3(self, c, buff, maxitem, (&form), __arg1);
          ok = _ret2.r1;
          nb = _ret2.r2;
          goto nelua_next_4;
        }
nelua_next_4:;
        if(!ok) {
          return false;
        }
        _nelua_assert_line25((nb >= 0), ((nlstring){(uint8_t*)"missing argument in format", 26}));
        nelua_stringbuilderT_commit(self, (uintptr_t)nb);
      }
    }
  }
  return true;
}
void _nelua_assert_line26(bool cond, nlstring msg) {
  if(nelua_unlikely(!cond)) {
    fwrite("/home/bart/projects/nelua/nelua-lang/lib/stringbuilder.nelua:244:18: runtime error: ", 1, 84, stderr);
    fwrite(msg.data, msg.size, 1, stderr);
    fwrite("\n          assert(nb >= 0, 'missing argument in format')\n                 ^~~~~~~\n", 1, 82, stderr);
    nelua_abort();
  }
}
bool nelua_stringbuilderT_write_format_4(nelua_stringbuilderT_ptr self, nlstring fmt) {
  uintptr_t pos = (uintptr_t)0U;
  int32_t argi = 0;
  while(pos < fmt.size) {
    uint8_t c = (fmt.data)[pos];
    pos = (pos + 1);
    if(c != 37U) {
      if(!nelua_stringbuilderT_write_byte(self, c)) {
        return false;
      }
    } else {
      c = (fmt.data)[pos];
      if(c == 37U) {
        if(!nelua_stringbuilderT_write_byte(self, 37U)) {
          return false;
        }
        pos = (pos + 1);
      } else {
        nluint8_arr32 form = {0};
        char* buff = (char*)nelua_stringbuilderT_prepare(self, 120U);
        if(!(buff != NULL)) {
          return false;
        }
        pos = (pos + nelua_scanformat(((nluint8_arr0_ptr)(&(fmt.data)[pos])), (&form)));
        c = (fmt.data)[pos];
        pos = (pos + 1);
        argi = (argi + 1);
        bool ok = false;
        int nb = -1;
        if(!ok) {
          return false;
        }
        _nelua_assert_line26((nb >= 0), ((nlstring){(uint8_t*)"missing argument in format", 26}));
        nelua_stringbuilderT_commit(self, (uintptr_t)nb);
      }
    }
  }
  return true;
}
nlstring nelua_stringbuilderT_view(nelua_stringbuilderT_ptr self) {
  if(nelua_unlikely((self->size == 0))) {
    return (nlstring){0};
  }
  return (nlstring){.data = ((nluint8_arr0_ptr)(&(*nelua_span_uint8___atindex(&self->data, 0U)))), .size = self->size};
}
void nelua_nlstring_destroy(nlstring s) {
  if(s.size > 0) {
    nelua_GeneralAllocator_dealloc(&nelua_general_allocator, (void*)s.data);
    s.data = NULL;
    s.size = (uintptr_t)0U;
  }
}
nlstring nelua_nlstring_copy(nlstring s) {
  nlstring clone = {0};
  if(nelua_unlikely((s.size == 0))) {
    return clone;
  }
  clone.data = ((nluint8_arr0_ptr)nelua_GeneralAllocator_xalloc(&nelua_general_allocator, (s.size + 1)));
  nelua_memory_copy((void*)clone.data, (void*)s.data, s.size);
  (clone.data)[s.size] = (uint8_t)0U;
  clone.size = s.size;
  return clone;
}
nlmulret_nlisize_nlisize nelua_nlstring_find_1(nlstring s, nlstring pattern, nlniltype init, nlniltype plain) {
  intptr_t init_1 = 1;
  bool plain_1 = false;
  nelua_PatternMatcher ms = nelua_PatternMatcher_create(s, pattern);
  nlmulret_nlisize_nlisize _ret3 = nelua_PatternMatcher_match(&ms, init_1, plain_1);
  intptr_t startpos = _ret3.r1;
  intptr_t endpos = _ret3.r2;
  if(endpos != -1) {
    return (nlmulret_nlisize_nlisize){(startpos + 1), endpos};
  } else {
    return (nlmulret_nlisize_nlisize){0, 0};
  }
}
void _nelua_assert_line27(bool cond, nlstring msg) {
  if(nelua_unlikely(!cond)) {
    fwrite("/home/bart/projects/nelua/nelua-lang/lib/string.nelua:243:14: runtime error: ", 1, 77, stderr);
    fwrite(msg.data, msg.size, 1, stderr);
    fwrite("\n      assert(state.ms.numcaptures <= MAX_CAPTURES, 'too many captures')\n             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n", 1, 123, stderr);
    nelua_abort();
  }
}
nlmulret_nlboolean_nlstring_nelua_span_string nelua_gmatch_next(nelua_GMatchState_ptr state, nlstring it) {
  bool ok = false;
  nlstring matched = {0};
  nelua_span_string captures = {0};
  nlmulret_nlisize_nlisize _ret4 = nelua_PatternMatcher_match(&state->ms, state->init, false);
  intptr_t s_8 = _ret4.r1;
  intptr_t e = _ret4.r2;
  if(e != -1) {
    ok = true;
    state->init = (e + 2);
    matched = (nlstring){.data = ((nluint8_arr0_ptr)(&(state->ms.source.data)[s_8])), .size = (uintptr_t)(e - s_8)};
    _nelua_assert_line27((state->ms.numcaptures <= 8), ((nlstring){(uint8_t*)"too many captures", 17}));
    for(intptr_t i = 0, _end = state->ms.numcaptures; i < _end; i = i + 1) {
      state->captures[i] = nelua_PatternMatcher_get_capture(&state->ms, i);
    }
    captures = (nelua_span_string){.data = ((nlstring_arr0_ptr)(&state->captures[0])), .size = (uintptr_t)state->ms.numcaptures};
  }
  return (nlmulret_nlboolean_nlstring_nelua_span_string){ok, matched, captures};
}
nlmulret_function_PhfPeGGJMcY1eas6_nelua_GMatchState_nlstring nelua_nlstring_gmatchview_1(nlstring s, nlstring pattern, nlniltype init) {
  intptr_t init_2 = 1;
  nelua_GMatchState state = (nelua_GMatchState){.ms = nelua_PatternMatcher_create(s, pattern), .init = init_2};
  return (nlmulret_function_PhfPeGGJMcY1eas6_nelua_GMatchState_nlstring){nelua_gmatch_next, state, (nlstring){0}};
}
intptr_t nelua_nlstring___len(nlstring a) {
  return (intptr_t)a.size;
}
bool nelua_nlstring___eq(nlstring a, nlstring b) {
  return ((a.size == b.size) && (((a.data == b.data) || (a.size == 0)) || nelua_memory_equals((void*)a.data, (void*)b.data, a.size)));
}
bool nelua_tocstring(nlcchar_arr0_ptr buf, uintptr_t buflen, nlstring s) {
  if((buf != NULL) && (buflen >= (s.size + 1))) {
    nelua_memory_copy((void*)buf, (void*)(&(s.data)[0]), s.size);
    (buf)[s.size] = 0;
    return true;
  }
  return false;
}
nlstring nelua_tostring_1(uint64_t x) {
  int size = snprintf(NULL, (size_t)0U, "%" PRIu64, x);
  if(nelua_unlikely((size <= 0))) {
    return (nlstring){0};
  }
  nlstring s = nelua_nlstring__create((uintptr_t)size);
  char* dest = (char*)(&(s.data)[0]);
  size_t n = (size_t)(size + 1);
  snprintf(dest, n, "%" PRIu64, x);
  return s;
}
void _nelua_assert_line28(bool cond) {
  if(nelua_unlikely(!cond)) {
    fwrite("/home/bart/projects/nelua/nelua-lang/lib/string.nelua:708:21: runtime error: assertion failed!\n    assert(tocstring(&tmpbuf, #tmpbuf, x)) -- ensure it's zero terminated\n                    ^~~~~~~~~~~~~~~~~~~~~\n", 1, 211, stderr);
    nelua_abort();
  }
}
void _nelua_assert_line29(bool cond, nlstring msg) {
  if(nelua_unlikely(!cond)) {
    fwrite("/home/bart/projects/nelua/nelua-lang/lib/string.nelua:712:12: runtime error: ", 1, 77, stderr);
    fwrite(msg.data, msg.size, 1, stderr);
    fwrite("\n    assert(len > 0 and len <= #x and errno == 0, 'failed to convert string to integer')\n           ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n", 1, 137, stderr);
    nelua_abort();
  }
}
bool nelua_lt_nlisize_nlusize(intptr_t a, uintptr_t b) {
  return a < 0 || (uint64_t)a < b;
}
int64_t nelua_tointeger_1(char* x, nlniltype base) {
  char* endptr = NULL;
  nlcchar_arr65 tmpbuf = {0};
  _nelua_assert_line28(nelua_tocstring(((nlcchar_arr0_ptr)(&tmpbuf)), 65U, nelua_cstring2string(x)));
  errno = 0;
  long long i = strtoll((char*)(&tmpbuf), (&endptr), 10);
  uintptr_t len = ((uintptr_t)endptr - (uintptr_t)(&tmpbuf));
  _nelua_assert_line29((((len > 0) && (!nelua_lt_nlisize_nlusize((((intptr_t)strlen(x))), len))) && (errno == 0)), ((nlstring){(uint8_t*)"failed to convert string to integer", 35}));
  return (int64_t)i;
}
nlstring sys_resolvpath(nlstring path) {
  nlcchar_arr4097 resolved_path = {0};
  if((nelua_nlstring___len(path) < 4097) && (realpath(nelua_string2cstring(path), (&resolved_path.data[0])) != NULL)) {
    return nelua_nlstring_copy(nelua_cstring2string((&resolved_path.data[0])));
  }
  return ((nlstring){(uint8_t*)"", 0});
}
uintptr_t nelua_lhash(nluint8_arr0_ptr data, uintptr_t len, uintptr_t seed, uintptr_t step) {
  seed = (seed ^ len);
  while(len >= step) {
    seed = (seed ^ (((seed << 5) + (seed >> 2)) + (data)[(len - 1)]));
    len = (len - step);
  }
  return seed;
}
uintptr_t nelua_hash_long(nelua_span_uint8 data) {
  return nelua_lhash(data.data, data.size, (uintptr_t)0x9e3779b9U, ((data.size >> 5) + 1));
}
uintptr_t nelua_hash_hash_1(nlstring v) {
  return nelua_hash_long((nelua_span_uint8){.data = v.data, .size = v.size});
}
uintptr_t nelua_ceil_idiv(uintptr_t x, uintptr_t y) {
  return (((x + y) - 1) / y);
}
nlmulret_nlusize_nlusize_nlusize forkmonhook_hashmap_stringboolean__find(forkmonhook_hashmap_stringboolean_ptr self, nlstring key) {
  if(nelua_unlikely((self->buckets.size == 0))) {
    return (nlmulret_nlusize_nlusize_nlusize){UINTPTR_MAX, UINTPTR_MAX, UINTPTR_MAX};
  }
  uintptr_t hash_index = (nelua_hash_hash_1(key) % self->buckets.size);
  uintptr_t node_index = (*forkmonhook_span_usize___atindex(&self->buckets, hash_index));
  uintptr_t prev_node_index = UINTPTR_MAX;
  while(node_index != UINTPTR_MAX) {
    forkmonhook_hashmap_node_nil_ptr node = (&(*forkmonhook_span_hashmap_node_nil___atindex(&self->nodes, node_index)));
    if(nelua_nlstring___eq(node->key, key)) {
      return (nlmulret_nlusize_nlusize_nlusize){node_index, prev_node_index, hash_index};
    }
    prev_node_index = node_index;
    node_index = node->next;
  }
  return (nlmulret_nlusize_nlusize_nlusize){node_index, prev_node_index, hash_index};
}
void forkmonhook_hashmap_stringboolean_rehash(forkmonhook_hashmap_stringboolean_ptr self, uintptr_t count) {
  uintptr_t min_count = nelua_ceil_idiv((self->size * 100), 75U);
  if(count < min_count) {
    count = min_count;
  }
  uintptr_t nodes_count = ((count * 75U) / 100);
  if(nodes_count > self->nodes.size) {
    self->nodes = nelua_GeneralAllocator_spanxrealloc0_4(&self->allocator, self->nodes, nodes_count);
  }
  if(count <= self->buckets.size) {
    return;
  }
  self->buckets = nelua_GeneralAllocator_spanxrealloc_2(&self->allocator, self->buckets, count);
  nelua_memory_spanset_1(self->buckets, UINTPTR_MAX);
  for(uintptr_t i = 0U, _end = self->size; i < _end; i = i + 1) {
    (*forkmonhook_span_hashmap_node_nil___atindex(&self->nodes, i)).next = UINTPTR_MAX;
  }
  for(uintptr_t i = 0U, _end = self->size; i < _end; i = i + 1) {
    nlmulret_nlusize_nlusize_nlusize _ret5 = forkmonhook_hashmap_stringboolean__find(self, (*forkmonhook_span_hashmap_node_nil___atindex(&self->nodes, i)).key);
    uintptr_t node_index = _ret5.r1;
    uintptr_t prev_node_index = _ret5.r2;
    uintptr_t hash_index = _ret5.r3;
    if(prev_node_index == UINTPTR_MAX) {
      (*forkmonhook_span_usize___atindex(&self->buckets, hash_index)) = i;
    } else {
      (*forkmonhook_span_hashmap_node_nil___atindex(&self->nodes, prev_node_index)).next = i;
    }
    (*forkmonhook_span_hashmap_node_nil___atindex(&self->nodes, i)).next = node_index;
  }
}
void forkmonhook_hashmap_stringboolean_reserve(forkmonhook_hashmap_stringboolean_ptr self, uintptr_t count) {
  forkmonhook_hashmap_stringboolean_rehash(self, nelua_ceil_idiv((count * 100), 75U));
}
uintptr_t forkmonhook_hashmap_stringboolean__find_or_make(forkmonhook_hashmap_stringboolean_ptr self, nlstring key) {
  if(nelua_unlikely((self->nodes.size == 0))) {
    forkmonhook_hashmap_stringboolean_reserve(self, 16U);
  }
  nlmulret_nlusize_nlusize_nlusize _ret6 = forkmonhook_hashmap_stringboolean__find(self, key);
  uintptr_t node_index = _ret6.r1;
  uintptr_t prev_node_index = _ret6.r2;
  uintptr_t hash_index = _ret6.r3;
  if(node_index != UINTPTR_MAX) {
    return node_index;
  } else {
    uintptr_t node_index_1 = self->size;
    (*forkmonhook_span_hashmap_node_nil___atindex(&self->nodes, node_index_1)) = (forkmonhook_hashmap_node_nil){.key = key, .next = UINTPTR_MAX};
    self->size = (self->size + 1);
    if(prev_node_index == UINTPTR_MAX) {
      (*forkmonhook_span_usize___atindex(&self->buckets, hash_index)) = node_index_1;
    } else {
      (*forkmonhook_span_hashmap_node_nil___atindex(&self->nodes, prev_node_index)).next = node_index_1;
    }
    if(nelua_unlikely((self->size >= ((75U * self->buckets.size) / 100)))) {
      forkmonhook_hashmap_stringboolean_reserve(self, ((self->size * 200U) / 100));
    }
    return node_index_1;
  }
}
nlboolean_ptr forkmonhook_hashmap_stringboolean_peek(forkmonhook_hashmap_stringboolean_ptr self, nlstring key) {
  uintptr_t node_index = ({
    nlmulret_nlusize_nlusize_nlusize _ret7 = forkmonhook_hashmap_stringboolean__find(self, key);
    _ret7.r1;
  });
  if(node_index != UINTPTR_MAX) {
    return (&(*forkmonhook_span_hashmap_node_nil___atindex(&self->nodes, node_index)).value);
  }
  return NULL;
}
void forkmonhook_hashmap_stringboolean_set(forkmonhook_hashmap_stringboolean_ptr self, nlstring key, bool value) {
  (*forkmonhook_span_hashmap_node_nil___atindex(&self->nodes, forkmonhook_hashmap_stringboolean__find_or_make(self, key))).value = value;
}
void nelua_SlotPoolT_reserve(nelua_SlotPoolT_ptr self, uint32_t size) {
  if(size <= self->size) {
    return;
  }
  self->gen_ctrs = nelua_GeneralAllocator_spanxrealloc0_2(&self->allocator, self->gen_ctrs, (uintptr_t)(size + 1));
  self->free_queue = nelua_GeneralAllocator_spanxrealloc0_2(&self->allocator, self->free_queue, (uintptr_t)size);
  for(uint32_t i = size, _end = (self->size + 1); i >= _end; i = i + -1) {
    (*nelua_span_uint32___atindex(&self->free_queue, (uintptr_t)self->queue_top)) = i;
    self->queue_top = (self->queue_top + 1);
  }
  self->size = size;
}
void nelua_SlotPoolT_destroy(nelua_SlotPoolT_ptr self) {
  nelua_GeneralAllocator_spandealloc_3(&self->allocator, self->free_queue);
  nelua_GeneralAllocator_spandealloc_3(&self->allocator, self->gen_ctrs);
  self->size = (uint32_t)0U;
  self->queue_top = (uint32_t)0U;
  self->gen_ctrs = (nelua_span_uint32){0};
  self->free_queue = (nelua_span_uint32){0};
}
uint32_t nelua_SlotPoolT_acquire_index(nelua_SlotPoolT_ptr self) {
  if(nelua_unlikely((self->queue_top == 0))) {
    uint32_t newsize = 0U;
    if(self->size == 0) {
      newsize = 64U;
    } else {
      newsize = (self->size * 2);
    }
    nelua_SlotPoolT_reserve(self, newsize);
  }
  self->queue_top = (self->queue_top - 1);
  uint32_t slot_index = (*nelua_span_uint32___atindex(&self->free_queue, (uintptr_t)self->queue_top));
  return slot_index;
}
uint32_t nelua_SlotPoolT_get_index(nelua_SlotPoolT_ptr self, uint64_t id) {
  uint32_t slot_index = (uint32_t)(id & 4294967295);
  if(nelua_unlikely(((slot_index == 0) || (slot_index > self->size)))) {
    return 0U;
  }
  uint32_t slot_genid = (uint32_t)(id >> 32);
  if(nelua_unlikely((slot_genid != (*nelua_span_uint32___atindex(&self->gen_ctrs, (uintptr_t)slot_index))))) {
    return 0U;
  }
  return slot_index;
}
nlmulret_nluint64_nluint32 nelua_SlotPoolT_acquire_slot(nelua_SlotPoolT_ptr self) {
  uint32_t slot_index = nelua_SlotPoolT_acquire_index(self);
  uint32_t slot_genid = (*nelua_span_uint32___atindex(&self->gen_ctrs, (uintptr_t)slot_index));
  uint64_t slot_id = ((uint64_t)(((uint64_t)slot_genid << 32) | (slot_index & 4294967295)));
  return (nlmulret_nluint64_nluint32){slot_id, slot_index};
}
void nelua_grow_items(nelua_ResourcePool_FStream_ptr self) {
  if(self->items.size < self->slot_pool.gen_ctrs.size) {
    self->items = nelua_GeneralAllocator_spanxrealloc0_3(&self->allocator, self->items, self->slot_pool.gen_ctrs.size);
  }
}
void nelua_ResourcePool_FStream_destroy(nelua_ResourcePool_FStream_ptr self) {
  nelua_SlotPoolT_destroy(&self->slot_pool);
  nelua_GeneralAllocator_spandealloc_4(&self->allocator, self->items);
  self->items = (nelua_span_FStream){0};
}
nelua_FStream_ptr nelua_ResourcePool_FStream_get(nelua_ResourcePool_FStream_ptr self, uint64_t id) {
  uint32_t slot_index = nelua_SlotPoolT_get_index(&self->slot_pool, id);
  if(nelua_unlikely((slot_index == 0))) {
    return NULL;
  }
  return (&(*nelua_span_FStream___atindex(&self->items, (uintptr_t)slot_index)));
}
nlmulret_nluint64_nelua_FStream_ptr nelua_ResourcePool_FStream_acquire(nelua_ResourcePool_FStream_ptr self) {
  nlmulret_nluint64_nluint32 _ret8 = nelua_SlotPoolT_acquire_slot(&self->slot_pool);
  uint64_t slot_id = _ret8.r1;
  uint32_t slot_index = _ret8.r2;
  nelua_grow_items(self);
  return (nlmulret_nluint64_nelua_FStream_ptr){slot_id, (&(*nelua_span_FStream___atindex(&self->items, (uintptr_t)slot_index)))};
}
void nelua_destroy_pool() {
  nelua_ResourcePool_FStream_destroy(&nelua_pool);
}
nlmulret_nlboolean_nlstring_nlint64 nelua_fileresult(bool success) {
  if(!success) {
    return (nlmulret_nlboolean_nlstring_nlint64){false, nelua_cstring2string(strerror(errno)), (int64_t)errno};
  }
  return (nlmulret_nlboolean_nlstring_nlint64){true, ((nlstring){(uint8_t*)"", 0}), 0};
}
nelua_filestream nelua_filestream__from_fp(FILE_ptr fp, function_63k29A1LdRYgBUca closef) {
  nlmulret_nluint64_nelua_FStream_ptr _ret9 = nelua_ResourcePool_FStream_acquire(&nelua_pool);
  uint64_t id = _ret9.r1;
  nelua_FStream_ptr p = _ret9.r2;
  p->fp = fp;
  p->closef = closef;
  return (nelua_filestream){.id = id};
}
FILE_ptr nelua_filestream__get_fp(nelua_filestream_ptr self) {
  nelua_FStream_ptr p = nelua_ResourcePool_FStream_get(&nelua_pool, self->id);
  if((p != NULL)) {
    return p->fp;
  }
  return NULL;
}
nlmulret_nlboolean_nlstring_nlint64 nelua_filestream_flush(nelua_filestream_ptr self) {
  FILE_ptr fp = nelua_filestream__get_fp(self);
  if(!(fp != NULL)) {
    return (nlmulret_nlboolean_nlstring_nlint64){false, ((nlstring){(uint8_t*)"attempt to use a closed file", 28}), -1};
  }
  nlmulret_nlboolean_nlstring_nlint64 _ret10 = nelua_fileresult((fflush(fp) == 0));
  return (nlmulret_nlboolean_nlstring_nlint64){_ret10.r1, _ret10.r2, _ret10.r3};
}
nlmulret_nlboolean_nlstring_nlint64 nelua_filestream_write_1(nelua_filestream_ptr self, nlstring __arg1) {
  FILE_ptr fp = nelua_filestream__get_fp(self);
  if(!(fp != NULL)) {
    return (nlmulret_nlboolean_nlstring_nlint64){false, ((nlstring){(uint8_t*)"attempt to use a closed file", 28}), -1};
  }
  nlstring s = {0};
  s = __arg1;
  if(s.size > 0) {
    bool ok = (fwrite((void*)s.data, (size_t)1U, (size_t)s.size, fp) == s.size);
    if(!ok) {
      goto nelua_errout;
    }
  }
  return (nlmulret_nlboolean_nlstring_nlint64){true, ((nlstring){(uint8_t*)"", 0}), 0};
nelua_errout:;
  nlmulret_nlboolean_nlstring_nlint64 _ret11 = nelua_fileresult(false);
  return (nlmulret_nlboolean_nlstring_nlint64){_ret11.r1, _ret11.r2, _ret11.r3};
}
nlmulret_nlboolean_nlstring_nlint64 nelua_filestream_writef_1(nelua_filestream_ptr self, nlstring fmt, nlstring __arg1) {
  FILE_ptr fp = nelua_filestream__get_fp(self);
  if(!(fp != NULL)) {
    return (nlmulret_nlboolean_nlstring_nlint64){false, ((nlstring){(uint8_t*)"attempt to use a closed file", 28}), -1};
  }
  nelua_stringbuilderT sb = {0};
  if(!nelua_stringbuilderT_write_format_2(&sb, fmt, __arg1)) {
    nlmulret_nlboolean_nlstring_nlint64 _ret12 = (nlmulret_nlboolean_nlstring_nlint64){false, ((nlstring){(uint8_t*)"not enough memory", 17}), 0};
    { /* defer */
      nelua_stringbuilderT_destroy(&sb);
    }
    return _ret12;
  }
  nlstring s = nelua_stringbuilderT_view(&sb);
  if(s.size > 0) {
    size_t res = fwrite((void*)s.data, (size_t)1U, (size_t)s.size, fp);
    if(res != s.size) {
      nlmulret_nlboolean_nlstring_nlint64 _ret14 = nelua_fileresult(false);
      nlmulret_nlboolean_nlstring_nlint64 _ret13 = (nlmulret_nlboolean_nlstring_nlint64){_ret14.r1, _ret14.r2, _ret14.r3};
      { /* defer */
        nelua_stringbuilderT_destroy(&sb);
      }
      return _ret13;
    }
  }
  nlmulret_nlboolean_nlstring_nlint64 _ret15 = (nlmulret_nlboolean_nlstring_nlint64){true, ((nlstring){(uint8_t*)"", 0}), 0};
  { /* defer */
    nelua_stringbuilderT_destroy(&sb);
  }
  return _ret15;
}
nlmulret_nlboolean_nlstring_nlint64 nelua_filestream_writef_2(nelua_filestream_ptr self, nlstring fmt, char* __arg1) {
  FILE_ptr fp = nelua_filestream__get_fp(self);
  if(!(fp != NULL)) {
    return (nlmulret_nlboolean_nlstring_nlint64){false, ((nlstring){(uint8_t*)"attempt to use a closed file", 28}), -1};
  }
  nelua_stringbuilderT sb = {0};
  if(!nelua_stringbuilderT_write_format_3(&sb, fmt, __arg1)) {
    nlmulret_nlboolean_nlstring_nlint64 _ret16 = (nlmulret_nlboolean_nlstring_nlint64){false, ((nlstring){(uint8_t*)"not enough memory", 17}), 0};
    { /* defer */
      nelua_stringbuilderT_destroy(&sb);
    }
    return _ret16;
  }
  nlstring s = nelua_stringbuilderT_view(&sb);
  if(s.size > 0) {
    size_t res = fwrite((void*)s.data, (size_t)1U, (size_t)s.size, fp);
    if(res != s.size) {
      nlmulret_nlboolean_nlstring_nlint64 _ret18 = nelua_fileresult(false);
      nlmulret_nlboolean_nlstring_nlint64 _ret17 = (nlmulret_nlboolean_nlstring_nlint64){_ret18.r1, _ret18.r2, _ret18.r3};
      { /* defer */
        nelua_stringbuilderT_destroy(&sb);
      }
      return _ret17;
    }
  }
  nlmulret_nlboolean_nlstring_nlint64 _ret19 = (nlmulret_nlboolean_nlstring_nlint64){true, ((nlstring){(uint8_t*)"", 0}), 0};
  { /* defer */
    nelua_stringbuilderT_destroy(&sb);
  }
  return _ret19;
}
nlmulret_nlboolean_nlstring_nlint64 nelua_filestream_writef_3(nelua_filestream_ptr self, nlstring fmt) {
  FILE_ptr fp = nelua_filestream__get_fp(self);
  if(!(fp != NULL)) {
    return (nlmulret_nlboolean_nlstring_nlint64){false, ((nlstring){(uint8_t*)"attempt to use a closed file", 28}), -1};
  }
  nelua_stringbuilderT sb = {0};
  if(!nelua_stringbuilderT_write_format_4(&sb, fmt)) {
    nlmulret_nlboolean_nlstring_nlint64 _ret20 = (nlmulret_nlboolean_nlstring_nlint64){false, ((nlstring){(uint8_t*)"not enough memory", 17}), 0};
    { /* defer */
      nelua_stringbuilderT_destroy(&sb);
    }
    return _ret20;
  }
  nlstring s = nelua_stringbuilderT_view(&sb);
  if(s.size > 0) {
    size_t res = fwrite((void*)s.data, (size_t)1U, (size_t)s.size, fp);
    if(res != s.size) {
      nlmulret_nlboolean_nlstring_nlint64 _ret22 = nelua_fileresult(false);
      nlmulret_nlboolean_nlstring_nlint64 _ret21 = (nlmulret_nlboolean_nlstring_nlint64){_ret22.r1, _ret22.r2, _ret22.r3};
      { /* defer */
        nelua_stringbuilderT_destroy(&sb);
      }
      return _ret21;
    }
  }
  nlmulret_nlboolean_nlstring_nlint64 _ret23 = (nlmulret_nlboolean_nlstring_nlint64){true, ((nlstring){(uint8_t*)"", 0}), 0};
  { /* defer */
    nelua_stringbuilderT_destroy(&sb);
  }
  return _ret23;
}
int nelua_C_va_arg_1(nlcvalist_ptr ap, nlniltype T) {
  int va;
  va = va_arg(*ap, int);
  return va;
}
void forkmonhook_kill(int code) {
  sys_killwait(forkmonhook_root_pid, 12);
  exit(code);
}
void forkmonhook_logf_1(nlstring fmt, nlstring __arg1) {
  if(!forkmonhook_quiet) {
    if(!forkmonhook_no_colors) {
      nelua_filestream_write_1(&nelua_io_stderr, sys_Colors_Yellow);
    }
    nelua_filestream_write_1(&nelua_io_stderr, ((nlstring){(uint8_t*)"[forkmon] ", 10}));
    nelua_filestream_writef_1(&nelua_io_stderr, fmt, __arg1);
    if(!forkmonhook_no_colors) {
      nelua_filestream_write_1(&nelua_io_stderr, sys_Colors_Reset);
    }
    nelua_filestream_write_1(&nelua_io_stderr, ((nlstring){(uint8_t*)"\n", 1}));
    nelua_filestream_flush(&nelua_io_stderr);
  }
}
void forkmonhook_logf_2(nlstring fmt, char* __arg1) {
  if(!forkmonhook_quiet) {
    if(!forkmonhook_no_colors) {
      nelua_filestream_write_1(&nelua_io_stderr, sys_Colors_Yellow);
    }
    nelua_filestream_write_1(&nelua_io_stderr, ((nlstring){(uint8_t*)"[forkmon] ", 10}));
    nelua_filestream_writef_2(&nelua_io_stderr, fmt, __arg1);
    if(!forkmonhook_no_colors) {
      nelua_filestream_write_1(&nelua_io_stderr, sys_Colors_Reset);
    }
    nelua_filestream_write_1(&nelua_io_stderr, ((nlstring){(uint8_t*)"\n", 1}));
    nelua_filestream_flush(&nelua_io_stderr);
  }
}
void forkmonhook_errorf_1(nlstring fmt) {
  if(!forkmonhook_no_colors) {
    nelua_filestream_write_1(&nelua_io_stderr, sys_Colors_Red);
  }
  nelua_filestream_write_1(&nelua_io_stderr, ((nlstring){(uint8_t*)"[forkmon] ", 10}));
  nelua_filestream_writef_3(&nelua_io_stderr, fmt);
  if(!forkmonhook_no_colors) {
    nelua_filestream_write_1(&nelua_io_stderr, sys_Colors_Reset);
  }
  nelua_filestream_write_1(&nelua_io_stderr, ((nlstring){(uint8_t*)"\n", 1}));
  nelua_filestream_flush(&nelua_io_stderr);
  forkmonhook_kill(-1);
}
void forkmonhook_assertkill(bool cond, nlstring msg) {
  if(!cond) {
    forkmonhook_errorf_1(msg);
  }
}
bool forkmonhook_filter_filename(nlstring filename) {
  {
    nlmulret_function_LVr5rP9wJyrc2Fjq_nelua_sequence_string_nlint64 _ret24 = nelua_ipairs_1(forkmonhook_filter_patts);
    function_LVr5rP9wJyrc2Fjq __fornext = _ret24.r1;
    nelua_sequence_string __forstate = _ret24.r2;
    int64_t __forit = _ret24.r3;
    while(true) {
      bool __forcont;
      nlstring patt;
      nlmulret_nlboolean_nlint64_nlstring _ret25 = __fornext(__forstate, __forit);
      __forcont = _ret25.r1;
      __forit = _ret25.r2;
      patt = _ret25.r3;
      if(!__forcont) {
        break;
      }
      int64_t _ = __forit;
      {
        if(({
          nlmulret_nlisize_nlisize _ret26 = nelua_nlstring_find_1(filename, patt, NLNIL, NLNIL);
          _ret26.r1;
        }) != 0) {
          return true;
        }
      }
    }
  }
  return false;
}
nlmulret_nlcint_nlcint forkmonhook_inotify_init_watch(char* filename, int mask) {
  int fd = inotify_init();
  forkmonhook_assertkill((fd >= 0), ((nlstring){(uint8_t*)"failed to initialize inotify", 28}));
  int wd = inotify_add_watch(fd, filename, (uint32_t)mask);
  forkmonhook_assertkill((wd >= 0), ((nlstring){(uint8_t*)"failed to watch file", 20}));
  return (nlmulret_nlcint_nlcint){fd, wd};
}
bool forkmonhook_monitor_file(nlstring filename) {
  int inotify_mask = (((IN_MODIFY | IN_CREATE) | IN_DELETE_SELF) | IN_MOVE_SELF);
  if(forkmonhook_parent_inotify_fd >= 0) {
    int inotify_wd = inotify_add_watch(forkmonhook_parent_inotify_fd, nelua_string2cstring(filename), (uint32_t)inotify_mask);
    forkmonhook_assertkill((inotify_wd >= 0), ((nlstring){(uint8_t*)"failed to watch file", 20}));
    return false;
  }
  if(!forkmonhook_quiet) {
    forkmonhook_logf_1(((nlstring){(uint8_t*)"watch '%s'", 10}), filename);
  }
  int pid = fork();
  forkmonhook_assertkill((pid >= 0), ((nlstring){(uint8_t*)"fork failed", 11}));
  if(pid == 0) {
    setpgid(0, 0);
    return false;
  }
  forkmonhook_child_pid = pid;
  nlmulret_nlcint_nlcint _ret27 = forkmonhook_inotify_init_watch(nelua_string2cstring(filename), inotify_mask);
  int inotify_fd = _ret27.r1;
  int inotify_wd = _ret27.r2;
  nluint8_arr1024 buf = {0};
  while(true) {
    long res = read(inotify_fd, NULL, (size_t)0U);
    if((res == -1) && (errno == 4)) {
      forkmonhook_kill(0);
    }
    sys_usleep(forkmonhook_restart_delay);
    long len = read(inotify_fd, (void*)(&buf), 1024U);
    if(len > 0) {
      uint64_t now = sys_uticks();
      if((now - forkmonhook_last_restart_ticks) <= forkmonhook_ignore_delay) {
        continue;
      }
      forkmonhook_last_restart_ticks = now;
      bool wdchange = false;
      int64_t pos = 0;
      while(pos < len) {
        inotify_event_ptr event = ((inotify_event_ptr)(&buf.data[pos]));
        if(event->wd == inotify_wd) {
          wdchange = true;
          break;
        }
        pos = ((int64_t)((pos + 16) + event->len));
      }
      if(wdchange) {
        forkmonhook_logf_1(((nlstring){(uint8_t*)"file '%s' changed, resuming from it ...", 39}), filename);
        forkmonhook_parent_inotify_fd = inotify_fd;
      } else {
        forkmonhook_logf_1(((nlstring){(uint8_t*)"some file changed, resuming from '%s' ...", 41}), filename);
        forkmonhook_parent_inotify_fd = -1;
        close(inotify_fd);
        nlmulret_nlcint_nlcint _ret28 = forkmonhook_inotify_init_watch(nelua_string2cstring(filename), inotify_mask);
        inotify_fd = _ret28.r1;
        inotify_wd = _ret28.r2;
      }
      sys_killwait(pid, 12);
      pid = fork();
      forkmonhook_assertkill((pid >= 0), ((nlstring){(uint8_t*)"fork failed", 11}));
      if(pid == 0) {
        setpgid(0, 0);
        nlstring nowtext = nelua_tostring_1(now);
        setenv("FORKMON_RESTART_TICKS", nelua_string2cstring(nowtext), 1);
        nelua_nlstring_destroy(nowtext);
        return true;
      }
      forkmonhook_child_pid = pid;
    }
  }
  return false;
}
bool forkmonhook_track_file_open(char* name) {
  if(!forkmonhook_initialized) {
    return false;
  }
  nlstring filename = sys_resolvpath(nelua_cstring2string(name));
  if(((nelua_nlstring___eq(filename, ((nlstring){(uint8_t*)"", 0})) || (({
    nlmulret_nlisize_nlisize _ret29 = nelua_nlstring_find_1(filename, ((nlstring){(uint8_t*)"^/tmp", 5}), NLNIL, NLNIL);
    _ret29.r1;
  }) != 0)) || (!forkmonhook_filter_filename(filename))) || (forkmonhook_hashmap_stringboolean_peek(&forkmonhook_tracked_files, filename) != NULL)) {
    { /* defer */
      nelua_nlstring_destroy(filename);
    }
    return false;
  }
  forkmonhook_hashmap_stringboolean_set(&forkmonhook_tracked_files, nelua_nlstring_copy(filename), true);
  bool _ret30 = forkmonhook_monitor_file(filename);
  { /* defer */
    nelua_nlstring_destroy(filename);
  }
  return _ret30;
}
void forkmonhook_signal_handler(int signum) {
  if(forkmonhook_handling_signal) {
    return;
  }
  forkmonhook_handling_signal = true;
  if(forkmonhook_child_pid != 0) {
    sys_killwait(forkmonhook_child_pid, 12);
  }
  sys_killwait((-getpid()), 9);
  _exit(0);
}
void forkmonhook_parse_env() {
  char* quiet_env = getenv("FORKMON_QUIET");
  if((quiet_env != NULL)) {
    forkmonhook_quiet = true;
  }
  char* no_colors_env = getenv("FORKMON_NO_COLORS");
  if((no_colors_env != NULL)) {
    forkmonhook_no_colors = true;
  }
  char* filter_env = getenv("FORKMON_FILTER");
  if(!(filter_env != NULL)) {
    forkmonhook_errorf_1(((nlstring){(uint8_t*)_strlit1, 101}));
  }
  {
    nlmulret_function_PhfPeGGJMcY1eas6_nelua_GMatchState_nlstring _ret31 = nelua_nlstring_gmatchview_1(nelua_cstring2string(filter_env), ((nlstring){(uint8_t*)"[^;]+", 5}), NLNIL);
    function_PhfPeGGJMcY1eas6 __fornext = _ret31.r1;
    nelua_GMatchState __forstate = _ret31.r2;
    nlstring __forit = _ret31.r3;
    while(true) {
      bool __forcont;
      nlmulret_nlboolean_nlstring_nelua_span_string _ret32 = __fornext(&__forstate, __forit);
      __forcont = _ret32.r1;
      __forit = _ret32.r2;
      if(!__forcont) {
        break;
      }
      nlstring patt = __forit;
      {
        (*nelua_sequence_string___atindex(&forkmonhook_filter_patts, (uintptr_t)(nelua_sequence_string___len(&forkmonhook_filter_patts) + 1))) = patt;
      }
    }
  }
  forkmonhook_logf_2(((nlstring){(uint8_t*)"watching files with filter \"%s\" ...", 35}), filter_env);
  char* restart_delay_env = getenv("FORKMON_RESTART_DELAY");
  if((restart_delay_env != NULL)) {
    forkmonhook_restart_delay = (uint64_t)(nelua_tointeger_1(restart_delay_env, NLNIL) * 1000);
  }
  char* ignore_delay_env = getenv("FORKMON_IGNORE_DELAY");
  if((ignore_delay_env != NULL)) {
    forkmonhook_ignore_delay = (uint64_t)(nelua_tointeger_1(ignore_delay_env, NLNIL) * 1000);
  }
  unsetenv("LD_PRELOAD");
}
FILE_ptr fopen(const char* __restrict filename, const char* __restrict mode) {
  if(!(forkmonhook_orig_fopen != NULL)) {
    forkmonhook_orig_fopen = (forkmonhook_FopenFunc)dlsym(RTLD_NEXT, "fopen");
  }
  if((nelua_nlstring___eq(nelua_cstring2string(mode), ((nlstring){(uint8_t*)"r", 1})) || nelua_nlstring___eq(nelua_cstring2string(mode), ((nlstring){(uint8_t*)"rb", 2}))) && sys_filexists(filename)) {
    forkmonhook_track_file_open(filename);
  }
  FILE_ptr fp = forkmonhook_orig_fopen(filename, mode);
  return fp;
}
FILE_ptr fopen64(const char* __restrict filename, const char* __restrict mode) {
  if(!(forkmonhook_orig_fopen64 != NULL)) {
    forkmonhook_orig_fopen64 = (forkmonhook_FopenFunc)dlsym(RTLD_NEXT, "fopen64");
  }
  if((nelua_nlstring___eq(nelua_cstring2string(mode), ((nlstring){(uint8_t*)"r", 1})) || nelua_nlstring___eq(nelua_cstring2string(mode), ((nlstring){(uint8_t*)"rb", 2}))) && sys_filexists(filename)) {
    forkmonhook_track_file_open(filename);
  }
  FILE_ptr fp = forkmonhook_orig_fopen64(filename, mode);
  return fp;
}
int open(const char* __restrict path, int flags, ...) {
  if(!(forkmonhook_orig_open != NULL)) {
    forkmonhook_orig_open = (forkmonhook_OpenFunc)dlsym(RTLD_NEXT, "open");
  }
  int writeflags = 1091;
  if(((flags & writeflags) == 0) && sys_filexists(path)) {
    forkmonhook_track_file_open(path);
  }
  va_list args;
  va_start(args, flags);
  int mode = nelua_C_va_arg_1(&args, NLNIL);
  va_end(args);
  int fd = forkmonhook_orig_open(path, flags, mode);
  return fd;
}
void setup() {
  nelua_main(0, NULL);
}
int nelua_main(int nelua_argc, char** nelua_argv) {
  { /* require 'io' */
    { /* require 'filestream' */
      atexit(nelua_destroy_pool);
    }
    nelua_io_stderr = nelua_filestream__from_fp(stderr, (function_63k29A1LdRYgBUca)NULL);
    nelua_io_stdout = nelua_filestream__from_fp(stdout, (function_63k29A1LdRYgBUca)NULL);
    nelua_io_stdin = nelua_filestream__from_fp(stdin, (function_63k29A1LdRYgBUca)NULL);
  }
  forkmonhook_root_pid = getpid();
  {
    forkmonhook_assertkill((signal(12, forkmonhook_signal_handler) == (function_ExBujEjR8Nqr9hSv)0), ((nlstring){(uint8_t*)"failed to setup signal handler", 30}));
    forkmonhook_parse_env();
    forkmonhook_initialized = true;
  }
  return 0;
}
