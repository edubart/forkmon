/* Generated by Nelua 0.2.0-dev */
/* Compile command: gcc -x c "forkmon.c" -x none -pipe -fwrapv -fno-strict-aliasing -g -ldl -lm -o "forkmon" */
/* Compile hash: 2V1eUQLQzq473NfAwRMge5jig61F */
/* ------------------------------ DIRECTIVES -------------------------------- */
/* Disable some warnings that the generated code can trigger. */
#if defined(__clang__) && __clang_major__ >= 3
  #pragma clang diagnostic ignored "-Wtype-limits"
  #pragma clang diagnostic ignored "-Wwrite-strings"
  #pragma clang diagnostic ignored "-Wunused"
  #pragma clang diagnostic ignored "-Wunused-parameter"
  #pragma clang diagnostic ignored "-Wmissing-field-initializers"
  #pragma clang diagnostic ignored "-Wparentheses-equality"
  #pragma clang diagnostic ignored "-Wtautological-compare"
  #ifndef __cplusplus
    #pragma clang diagnostic ignored "-Wmissing-braces"
    #pragma clang diagnostic ignored "-Wincompatible-pointer-types"
    #pragma clang diagnostic error   "-Wimplicit-function-declaration"
    #pragma clang diagnostic error   "-Wimplicit-int"
  #else
    #pragma clang diagnostic ignored "-Wnarrowing"
  #endif
#elif defined(__GNUC__) && __GNUC__ >= 5
  #pragma GCC diagnostic ignored "-Wtype-limits"
  #pragma GCC diagnostic ignored "-Wwrite-strings"
  #pragma GCC diagnostic ignored "-Wunused-parameter"
  #pragma GCC diagnostic ignored "-Wunused-value"
  #pragma GCC diagnostic ignored "-Wunused-variable"
  #pragma GCC diagnostic ignored "-Wunused-function"
  #pragma GCC diagnostic ignored "-Wunused-but-set-variable"
  #pragma GCC diagnostic ignored "-Wmissing-field-initializers"
  #ifndef __cplusplus
    #pragma GCC diagnostic ignored "-Wmissing-braces"
    #pragma GCC diagnostic ignored "-Wincompatible-pointer-types"
    #pragma GCC diagnostic ignored "-Wdiscarded-qualifiers"
    #pragma GCC diagnostic error   "-Wimplicit-function-declaration"
    #pragma GCC diagnostic error   "-Wimplicit-int"
  #else
    #pragma GCC diagnostic ignored "-Wnarrowing"
  #endif
#endif
#if defined(_WIN32) && !defined(_CRT_SECURE_NO_WARNINGS)
  #define _CRT_SECURE_NO_WARNINGS
#endif
#define _GNU_SOURCE
#include <dlfcn.h>
#include <stdlib.h>
#include <stdio.h>
#include <errno.h>
#include <time.h>
#include <signal.h>
#include <unistd.h>
#include <sys/wait.h>
#include <sys/inotify.h>
#include <fcntl.h>
#include <stdint.h>
#include <stddef.h>
#include <stdbool.h>
#include <string.h>
/* Macro used to force inlining a function. */
#ifdef __GNUC__
  #define NELUA_INLINE __attribute__((always_inline)) inline
#elif defined(_MSC_VER)
  #define NELUA_INLINE __forceinline
#elif __STDC_VERSION__ >= 199901L
  #define NELUA_INLINE inline
#else
  #define NELUA_INLINE
#endif
/* Macro used for branch prediction. */
#if defined(__GNUC__) || defined(__clang__)
  #define NELUA_UNLIKELY(x) __builtin_expect(x, 0)
#else
  #define NELUA_UNLIKELY(x) (x)
#endif
#define NELUA_NIL (nlniltype){}
/* Macro used for branch prediction. */
#if defined(__GNUC__) || defined(__clang__)
  #define NELUA_LIKELY(x) __builtin_expect(x, 1)
#else
  #define NELUA_LIKELY(x) (x)
#endif
/* Macro used to import/export extern C functions. */
#ifdef __cplusplus
  #define NELUA_EXTERN extern "C"
#else
  #define NELUA_EXTERN extern
#endif
/* Macro used to generate traceback on aborts when sanitizing. */
#if defined(__clang__) && defined(__has_feature)
  #if __has_feature(undefined_behavior_sanitizer)
    #define NELUA_UBSAN_UNREACHABLE __builtin_unreachable
  #endif
#elif defined(__gnu_linux__) && defined(__GNUC__) && __GNUC__ >= 5
  NELUA_EXTERN void __ubsan_handle_builtin_unreachable(void*) __attribute__((weak));
  #define NELUA_UBSAN_UNREACHABLE() {if(&__ubsan_handle_builtin_unreachable) __builtin_unreachable();}
#endif
#ifndef NELUA_UBSAN_UNREACHABLE
  #define NELUA_UBSAN_UNREACHABLE()
#endif
/* Macro used to specify a function that never returns. */
#if __STDC_VERSION__ >= 201112L
  #define NELUA_NORETURN _Noreturn
#elif defined(__GNUC__)
  #define NELUA_NORETURN __attribute__((noreturn))
#elif defined(_MSC_VER)
  #define NELUA_NORETURN __declspec(noreturn)
#else
  #define NELUA_NORETURN
#endif
/* Macro used sign that a type punning cast may alias (related to strict aliasing). */
#ifdef __GNUC__
  #define NELUA_MAYALIAS __attribute__((may_alias))
#else
  #define NELUA_MAYALIAS
#endif
/* Macro used to force not inlining a function. */
#ifdef __GNUC__
  #define NELUA_NOINLINE __attribute__((noinline))
#elif defined(_MSC_VER)
  #define NELUA_NOINLINE __declspec(noinline)
#else
  #define NELUA_NOINLINE
#endif
#include <stdarg.h>
/* Macro used to export C functions. */
#ifdef _WIN32
  #define NELUA_CEXPORT NELUA_EXTERN __declspec(dllexport)
#elif defined(__GNUC__)
  #define NELUA_CEXPORT NELUA_EXTERN __attribute__((visibility("default")))
#else
  #define NELUA_CEXPORT NELUA_EXTERN
#endif
/* ------------------------------ DECLARATIONS ------------------------------ */
typedef struct nlstring nlstring;
typedef uint8_t* nluint8_arr0_ptr;
struct nlstring {
  nluint8_arr0_ptr data;
  uintptr_t size;
};
static nlstring sys_Colors_Yellow = {(uint8_t*)"\033[33m", 5};
static nlstring sys_Colors_Red = {(uint8_t*)"\033[31m", 5};
static nlstring sys_Colors_Reset = {(uint8_t*)"\033[0m", 4};
static void sys_usleep(uint64_t ms);
typedef struct timespec timespec;
typedef timespec* timespec_ptr;
static uint64_t sys_uticks(void);
static int sys_killwait(int pid, int sig);
typedef int* nlcint_ptr;
static bool sys_filexists(const char* path);
static nlstring sys_resolvpath(char* path, char* buf, int len);
static NELUA_INLINE void nelua_memory_copy(void* dest, void* src, uintptr_t n);
static NELUA_INLINE void nelua_memory_zero(void* dest, uintptr_t n);
static NELUA_INLINE int32_t nelua_memory_compare(void* a, void* b, uintptr_t n);
static NELUA_INLINE bool nelua_memory_equals(void* a, void* b, uintptr_t n);
static NELUA_INLINE void* nelua_memory_scan(void* src, uint8_t x, uintptr_t n);
static void* nelua_memory_find(void* haystack, uintptr_t haystacksize, void* needle, uintptr_t needlesize);
typedef uint8_t* nluint8_ptr;
typedef struct nelua_span_uint8_ nelua_span_uint8_;
typedef nelua_span_uint8_* nelua_span_uint8__ptr;
struct nelua_span_uint8_ {
  nluint8_arr0_ptr data;
  uintptr_t size;
};
static NELUA_INLINE bool nelua_span_uint8__empty(nelua_span_uint8__ptr self);
static NELUA_INLINE nluint8_ptr nelua_span_uint8____atindex(nelua_span_uint8__ptr self, uintptr_t i);
typedef uintptr_t* nlusize_ptr;
typedef struct nelua_span_usize_ nelua_span_usize_;
typedef nelua_span_usize_* nelua_span_usize__ptr;
typedef uintptr_t* nlusize_arr0_ptr;
struct nelua_span_usize_ {
  nlusize_arr0_ptr data;
  uintptr_t size;
};
static NELUA_INLINE nlusize_ptr nelua_span_usize____atindex(nelua_span_usize__ptr self, uintptr_t i);
typedef struct nelua_hashmapnode_string__boolean_ nelua_hashmapnode_string__boolean_;
typedef nelua_hashmapnode_string__boolean_* nelua_hashmapnode_string__boolean__ptr;
struct nelua_hashmapnode_string__boolean_ {
  nlstring key;
  bool value;
  bool filled;
  uintptr_t next;
};
typedef struct nelua_span_hashmapnode_string__boolean__ nelua_span_hashmapnode_string__boolean__;
typedef nelua_span_hashmapnode_string__boolean__* nelua_span_hashmapnode_string__boolean___ptr;
typedef nelua_hashmapnode_string__boolean_* nelua_hashmapnode_string__boolean__arr0_ptr;
struct nelua_span_hashmapnode_string__boolean__ {
  nelua_hashmapnode_string__boolean__arr0_ptr data;
  uintptr_t size;
};
static NELUA_INLINE nelua_hashmapnode_string__boolean__ptr nelua_span_hashmapnode_string__boolean_____atindex(nelua_span_hashmapnode_string__boolean___ptr self, uintptr_t i);
typedef struct nlniltype {} nlniltype;
typedef struct nlniltype nltype;
static NELUA_INLINE void nelua_memory_spanset_1(nelua_span_usize_ dest, uintptr_t x);
typedef struct nelua_GeneralAllocator nelua_GeneralAllocator;
struct nelua_GeneralAllocator {};
static nelua_GeneralAllocator nelua_general_allocator;
typedef nelua_GeneralAllocator* nelua_GeneralAllocator_ptr;
static NELUA_INLINE void* nelua_GeneralAllocator_alloc(nelua_GeneralAllocator_ptr self, uintptr_t size);
static NELUA_INLINE void* nelua_GeneralAllocator_alloc0(nelua_GeneralAllocator_ptr self, uintptr_t size);
static NELUA_INLINE void nelua_GeneralAllocator_dealloc(nelua_GeneralAllocator_ptr self, void* p);
static NELUA_INLINE void* nelua_GeneralAllocator_realloc(nelua_GeneralAllocator_ptr self, void* p, uintptr_t newsize, uintptr_t oldsize);
static void* nelua_GeneralAllocator_xalloc(nelua_GeneralAllocator_ptr self, uintptr_t size);
static NELUA_INLINE void nelua_write_stderr(const char* msg, uintptr_t len, bool flush);
static NELUA_NORETURN void nelua_abort(void);
static NELUA_NORETURN void nelua_panic_string(nlstring s);
static void* nelua_GeneralAllocator_realloc0(nelua_GeneralAllocator_ptr self, void* p, uintptr_t newsize, uintptr_t oldsize);
static nelua_span_usize_ nelua_GeneralAllocator_spanalloc_3(nelua_GeneralAllocator_ptr self, nlniltype T, uintptr_t size);
static nelua_span_uint8_ nelua_GeneralAllocator_spanalloc0_1(nelua_GeneralAllocator_ptr self, nlniltype T, uintptr_t size);
static nelua_span_hashmapnode_string__boolean__ nelua_GeneralAllocator_spanalloc0_2(nelua_GeneralAllocator_ptr self, nlniltype T, uintptr_t size);
static void nelua_GeneralAllocator_spandealloc_1(nelua_GeneralAllocator_ptr self, nelua_span_uint8_ s);
static nelua_span_usize_ nelua_GeneralAllocator_spanrealloc_3(nelua_GeneralAllocator_ptr self, nelua_span_usize_ s, uintptr_t size);
static nelua_span_usize_ nelua_GeneralAllocator_xspanrealloc_3(nelua_GeneralAllocator_ptr self, nelua_span_usize_ s, uintptr_t size);
static nelua_span_uint8_ nelua_GeneralAllocator_spanrealloc0_1(nelua_GeneralAllocator_ptr self, nelua_span_uint8_ s, uintptr_t size);
static nelua_span_hashmapnode_string__boolean__ nelua_GeneralAllocator_spanrealloc0_2(nelua_GeneralAllocator_ptr self, nelua_span_hashmapnode_string__boolean__ s, uintptr_t size);
static nelua_span_hashmapnode_string__boolean__ nelua_GeneralAllocator_xspanrealloc0_1(nelua_GeneralAllocator_ptr self, nelua_span_hashmapnode_string__boolean__ s, uintptr_t size);
static NELUA_INLINE bool nelua_strchar_1_isalpha(uint8_t c);
static NELUA_INLINE bool nelua_strchar_1_islower(uint8_t c);
static NELUA_INLINE bool nelua_strchar_1_isupper(uint8_t c);
static NELUA_INLINE bool nelua_strchar_1_isdigit(uint8_t c);
static NELUA_INLINE bool nelua_strchar_1_isxdigit(uint8_t c);
static NELUA_INLINE bool nelua_strchar_1_iscntrl(uint8_t c);
static NELUA_INLINE bool nelua_strchar_1_isgraph(uint8_t c);
static NELUA_INLINE bool nelua_strchar_1_isspace(uint8_t c);
static NELUA_INLINE bool nelua_strchar_1_isalnum(uint8_t c);
static NELUA_INLINE bool nelua_strchar_1_ispunct(uint8_t c);
static NELUA_INLINE uint8_t nelua_strchar_1_getbasedigit(uint8_t c);
typedef struct NELUA_MAYALIAS nluint8_arr32 {uint8_t v[32];} nluint8_arr32;
typedef union NELUA_MAYALIAS nluint8_arr32_cast {nluint8_arr32 a; uint8_t p[32];} nluint8_arr32_cast;
typedef nluint8_arr32* nluint8_arr32_ptr;
static uintptr_t nelua_scanformat(nluint8_arr0_ptr strfmt, nluint8_arr32_ptr form);
static void nelua_assert_line_1(bool cond, nlstring msg);
static void nelua_assert_line_2(bool cond, nlstring msg);
typedef struct nelua_stringbuilderT nelua_stringbuilderT;
typedef nelua_stringbuilderT* nelua_stringbuilderT_ptr;
struct nelua_stringbuilderT {
  nelua_span_uint8_ data;
  uintptr_t size;
  nelua_GeneralAllocator allocator;
};
static void nelua_stringbuilderT_destroy(nelua_stringbuilderT_ptr self);
static bool nelua_stringbuilderT_grow(nelua_stringbuilderT_ptr self, uintptr_t newsize);
static nelua_span_uint8_ nelua_stringbuilderT_prepare(nelua_stringbuilderT_ptr self, uintptr_t n);
static void nelua_stringbuilderT_commit(nelua_stringbuilderT_ptr self, uintptr_t n);
static bool nelua_stringbuilderT_writebyte_1(nelua_stringbuilderT_ptr self, uint8_t c, nlniltype n);
typedef struct nlmulret_nlboolean_nlisize {
  bool r1;
  intptr_t r2;
} nlmulret_nlboolean_nlisize;
static nlmulret_nlboolean_nlisize nelua_formatarg_2(nelua_stringbuilderT_ptr self, uint8_t c, nluint8_arr32_ptr form, nlstring arg1);
static void nelua_assert_line_3(bool cond, nlstring msg);
static void nelua_assert_line_4(bool cond, nlstring msg);
typedef struct nlmulret_nlboolean_nlusize {
  bool r1;
  uintptr_t r2;
} nlmulret_nlboolean_nlusize;
static nlmulret_nlboolean_nlusize nelua_stringbuilderT_writef_2(nelua_stringbuilderT_ptr self, nlstring fmt, nlstring __arg1);
static void nelua_assert_line_5(bool cond, nlstring msg);
static nlmulret_nlboolean_nlusize nelua_stringbuilderT_writef_3(nelua_stringbuilderT_ptr self, nlstring fmt);
static void nelua_assert_line_6(bool cond, nlstring msg);
static nlstring nelua_stringbuilderT_view(nelua_stringbuilderT_ptr self);
typedef nlstring* nlstring_ptr;
static void nelua_nlstring_destroy(nlstring_ptr self);
static nlstring nelua_nlstring_copy(nlstring s);
static NELUA_INLINE intptr_t nelua_nlstring___len(nlstring a);
static bool nelua_nlstring___eq(nlstring a, nlstring b);
typedef struct nelua_StrPattCapture nelua_StrPattCapture;
typedef nelua_StrPattCapture* nelua_StrPattCapture_ptr;
struct nelua_StrPattCapture {
  intptr_t init;
  intptr_t len;
};
static bool nelua_StrPattCapture_is_unfinished(nelua_StrPattCapture_ptr self);
static bool nelua_StrPattCapture_is_position(nelua_StrPattCapture_ptr self);
static bool nelua_match_has_pattern_specials(nlstring pattern);
static bool nelua_match_has_pattern_anchor(nlstring pattern);
typedef struct nelua_StrPatt_1 nelua_StrPatt_1;
struct nelua_StrPatt_1 {
  nlstring source;
  nlstring pattern;
  intptr_t depth;
  intptr_t numcaptures;
  nelua_StrPattCapture capture[32];
  bool plain;
  bool anchor;
};
static nelua_StrPatt_1 nelua_StrPatt_1_create(nlstring source, nlstring pattern, bool plain);
typedef nelua_StrPatt_1* nelua_StrPatt_1_ptr;
static void nelua_StrPatt_1_reset_captures(nelua_StrPatt_1_ptr self);
typedef struct NELUA_MAYALIAS nelua_StrPattCapture_arr32 {nelua_StrPattCapture v[32];} nelua_StrPattCapture_arr32;
typedef union NELUA_MAYALIAS nelua_StrPattCapture_arr32_cast {nelua_StrPattCapture_arr32 a; nelua_StrPattCapture p[32];} nelua_StrPattCapture_arr32_cast;
typedef struct nlmulret_nlboolean_nlstring_nelua_StrPattCapture {
  bool r1;
  nlstring r2;
  nelua_StrPattCapture r3;
} nlmulret_nlboolean_nlstring_nelua_StrPattCapture;
static nlmulret_nlboolean_nlstring_nelua_StrPattCapture nelua_StrPatt_1_get_capture(nelua_StrPatt_1_ptr self, intptr_t i);
static intptr_t nelua_StrPatt_1__match(nelua_StrPatt_1_ptr ms, intptr_t s, intptr_t p);
static bool nelua_match_class(uint8_t c, uint8_t cl);
static intptr_t nelua_match_class_end(nelua_StrPatt_1_ptr ms_1, intptr_t p_1);
static void nelua_assert_line_7(bool cond, nlstring msg);
static void nelua_assert_line_8(bool cond, nlstring msg);
static bool nelua_match_bracket_class(nelua_StrPatt_1_ptr ms_2, uint8_t c, intptr_t p_2, intptr_t ep);
static bool nelua_match_single(nelua_StrPatt_1_ptr ms_3, intptr_t s_1, intptr_t p_3, intptr_t ep);
static intptr_t nelua_match_balance(nelua_StrPatt_1_ptr ms_4, intptr_t s_2, intptr_t p_4);
static void nelua_assert_line_9(bool cond, nlstring msg);
static intptr_t nelua_match_max_expand(nelua_StrPatt_1_ptr ms_5, intptr_t s_3, intptr_t p_5, intptr_t ep);
static intptr_t nelua_match_min_expand(nelua_StrPatt_1_ptr ms_6, intptr_t s_4, intptr_t p_6, intptr_t ep);
static intptr_t nelua_match_start_capture(nelua_StrPatt_1_ptr ms_7, intptr_t s_5, intptr_t p_7, intptr_t what);
static void nelua_assert_line_10(bool cond, nlstring msg);
static intptr_t nelua_match_end_capture(nelua_StrPatt_1_ptr ms_8, intptr_t s_6, intptr_t p_8);
static void nelua_assert_line_11(bool cond, nlstring msg);
static intptr_t nelua_match_capture(nelua_StrPatt_1_ptr ms_9, intptr_t s_7, intptr_t l);
static void nelua_assert_line_12(bool cond, nlstring msg);
static void nelua_assert_line_13(bool cond, nlstring msg);
static void nelua_assert_line_14(bool cond, nlstring msg);
typedef struct nlmulret_nlisize_nlisize {
  intptr_t r1;
  intptr_t r2;
} nlmulret_nlisize_nlisize;
static nlmulret_nlisize_nlisize nelua_StrPatt_1_match(nelua_StrPatt_1_ptr ms, intptr_t s);
static nlmulret_nlisize_nlisize nelua_nlstring_find_1(nlstring s, nlstring pattern, nlniltype init, nlniltype plain);
typedef struct nelua_span_string_ nelua_span_string_;
typedef nlstring* nlstring_arr0_ptr;
struct nelua_span_string_ {
  nlstring_arr0_ptr data;
  uintptr_t size;
};
typedef struct nlmulret_nlboolean_nlstring_nelua_span_string_ {
  bool r1;
  nlstring r2;
  nelua_span_string_ r3;
} nlmulret_nlboolean_nlstring_nelua_span_string_;
typedef struct nelua_GMatchState nelua_GMatchState;
typedef nelua_GMatchState* nelua_GMatchState_ptr;
typedef nlmulret_nlboolean_nlstring_nelua_span_string_ (*function_AUXgMx1BRVnTYeGb)(nelua_GMatchState_ptr, nlstring);
struct nelua_GMatchState {
  nelua_StrPatt_1 ms;
  intptr_t init;
  nlstring captures[8];
};
typedef struct nlmulret_function_AUXgMx1BRVnTYeGb_nelua_GMatchState_nlstring {
  function_AUXgMx1BRVnTYeGb r1;
  nelua_GMatchState r2;
  nlstring r3;
} nlmulret_function_AUXgMx1BRVnTYeGb_nelua_GMatchState_nlstring;
static nlmulret_function_AUXgMx1BRVnTYeGb_nelua_GMatchState_nlstring nelua_nlstring_gmatchview_1(nlstring s, nlstring pattern, nlniltype init);
static nlmulret_nlboolean_nlstring_nelua_span_string_ nelua_gmatch_next(nelua_GMatchState_ptr state, nlstring it);
static void nelua_assert_line_15(bool cond, nlstring msg);
static void nelua_assert_line_16(bool cond, nlstring msg);
static void nelua_assert_line_17(bool cond, nlstring msg);
typedef struct NELUA_MAYALIAS nlstring_arr8 {nlstring v[8];} nlstring_arr8;
typedef union NELUA_MAYALIAS nlstring_arr8_cast {nlstring_arr8 a; nlstring p[8];} nlstring_arr8_cast;
typedef struct nlmulret_nlboolean_nlint64 {
  bool r1;
  int64_t r2;
} nlmulret_nlboolean_nlint64;
static nlmulret_nlboolean_nlint64 nelua_strconv_1_str2int(nlstring s, uint64_t base);
static void nelua_assert_line_18(bool cond, nlstring msg);
static nlstring nelua_strconv_1_int2str_1(uintptr_t x, nlniltype base);
typedef struct NELUA_MAYALIAS nluint8_arr48 {uint8_t v[48];} nluint8_arr48;
typedef union NELUA_MAYALIAS nluint8_arr48_cast {nluint8_arr48 a; uint8_t p[48];} nluint8_arr48_cast;
static nlstring nelua_tostring_1(uint64_t x);
static int64_t nelua_tointeger_1(char* x, nlniltype base);
static NELUA_INLINE nlstring nelua_cstring2string(const char* s);
static void nelua_assert_line_19(bool cond, nlstring msg);
static NELUA_INLINE uintptr_t nelua_lhash(nluint8_arr0_ptr data, uintptr_t len, uintptr_t seed, uintptr_t step);
static NELUA_INLINE uintptr_t nelua_hash_long(nelua_span_uint8_ data);
static uintptr_t nelua_hash_hash_1(nlstring v);
static NELUA_INLINE uintptr_t nelua_ceilidiv(uintptr_t x, uintptr_t y);
static NELUA_INLINE uintptr_t nelua_hashmod(uintptr_t h, uintptr_t n);
static NELUA_INLINE uintptr_t nelua_roundpow2(uintptr_t n);
typedef struct nlmulret_nlusize_nlusize_nlusize {
  uintptr_t r1;
  uintptr_t r2;
  uintptr_t r3;
} nlmulret_nlusize_nlusize_nlusize;
typedef struct nelua_hashmap_string__boolean_ nelua_hashmap_string__boolean_;
typedef nelua_hashmap_string__boolean_* nelua_hashmap_string__boolean__ptr;
struct nelua_hashmap_string__boolean_ {
  nelua_span_usize_ buckets;
  nelua_span_hashmapnode_string__boolean__ nodes;
  uintptr_t size;
  uintptr_t free_index;
  nelua_GeneralAllocator allocator;
};
static NELUA_INLINE nlmulret_nlusize_nlusize_nlusize nelua_hashmap_string__boolean___find(nelua_hashmap_string__boolean__ptr self, nlstring key);
static NELUA_NOINLINE void nelua_hashmap_string__boolean__rehash(nelua_hashmap_string__boolean__ptr self, uintptr_t bucket_count);
static uintptr_t nelua_hashmap_string__boolean___at(nelua_hashmap_string__boolean__ptr self, nlstring key);
typedef bool* nlboolean_ptr;
static nlboolean_ptr nelua_hashmap_string__boolean____atindex(nelua_hashmap_string__boolean__ptr self, nlstring key);
static nlboolean_ptr nelua_hashmap_string__boolean__peek(nelua_hashmap_string__boolean__ptr self, nlstring key);
typedef FILE* FILE_ptr;
typedef struct nelua_filestream nelua_filestream;
typedef nelua_filestream* nelua_filestream_ptr;
typedef struct nelua_FStream nelua_FStream;
typedef nelua_FStream* nelua_FStream_ptr;
struct nelua_filestream {
  nelua_FStream_ptr fs;
};
typedef int (*function_FhC6yq19frq2vAJH)(FILE_ptr);
struct nelua_FStream {
  FILE_ptr fp;
  function_FhC6yq19frq2vAJH closef;
};
static NELUA_INLINE FILE_ptr nelua_filestream__getfp(nelua_filestream_ptr self);
typedef struct nlmulret_nlstring_nlint64 {
  nlstring r1;
  int64_t r2;
} nlmulret_nlstring_nlint64;
static nlmulret_nlstring_nlint64 nelua_geterrno(void);
typedef struct nlmulret_nlboolean_nlstring_nlint64 {
  bool r1;
  nlstring r2;
  int64_t r3;
} nlmulret_nlboolean_nlstring_nlint64;
static nlmulret_nlboolean_nlstring_nlint64 nelua_filestream_flush(nelua_filestream_ptr self);
static nlmulret_nlboolean_nlstring_nlint64 nelua_filestream_write_1(nelua_filestream_ptr self, nlstring __arg1);
static nlmulret_nlboolean_nlstring_nlint64 nelua_filestream_writef_1(nelua_filestream_ptr self, nlstring fmt, nlstring __arg1);
static nlmulret_nlboolean_nlstring_nlint64 nelua_filestream_writef_2(nelua_filestream_ptr self, nlstring fmt);
static nelua_FStream nelua_stderrfs;
static nelua_filestream nelua_io_stderr;
static nltype nelua_require_io(nlniltype modname);
typedef va_list* nlcvalist_ptr;
static NELUA_INLINE int nelua_C_va_arg_1(nlcvalist_ptr ap, nlniltype T);
static uint64_t forkmon_restart_delay = 50000U;
static uint64_t forkmon_ignore_delay = 200000U;
static bool forkmon_initialized = false;
static bool forkmon_handling_signal = false;
static bool forkmon_quiet = false;
static bool forkmon_no_colors = false;
static bool forkmon_preload_disabled = false;
static int forkmon_parent_inotify_fd = -1;
static int forkmon_child_pid = 0;
static int forkmon_root_pid;
static uint64_t forkmon_last_restart_ticks;
static int forkmon_filter_patts_count = 0;
typedef struct NELUA_MAYALIAS nlstring_arr32 {nlstring v[32];} nlstring_arr32;
typedef union NELUA_MAYALIAS nlstring_arr32_cast {nlstring_arr32 a; nlstring p[32];} nlstring_arr32_cast;
static nlstring_arr32 forkmon_filter_patts;
static nelua_hashmap_string__boolean_ forkmon_tracked_files;
typedef FILE_ptr (*forkmon_FopenFunc)(char*, char*);
static forkmon_FopenFunc forkmon_orig_fopen;
static forkmon_FopenFunc forkmon_orig_fopen64;
typedef int (*forkmon_OpenFunc)(char*, int, int);
static forkmon_OpenFunc forkmon_orig_open;
static void forkmon_killapp(int code);
static void forkmon_logf_1(nlstring fmt, nlstring __arg1);
static void forkmon_errorf_1(nlstring fmt);
static void forkmon_assertkill(bool cond, nlstring msg);
static bool forkmon_filter_filename(nlstring filename);
typedef struct nlmulret_nlcint_nlcint {
  int r1;
  int r2;
} nlmulret_nlcint_nlcint;
static nlmulret_nlcint_nlcint forkmon_inotify_init_watch(char* filename, int mask);
static char nelua_strlit_1[85] = "failed to initialize inotify, maybe increase \"user.max_inotify_instances\" in sysctl?";
static bool forkmon_monitor_file(nlstring filename);
static NELUA_INLINE char* nelua_string2cstring(nlstring s);
typedef struct NELUA_MAYALIAS nluint8_arr1024 {uint8_t v[1024];} nluint8_arr1024;
typedef union NELUA_MAYALIAS nluint8_arr1024_cast {nluint8_arr1024 a; uint8_t p[1024];} nluint8_arr1024_cast;
typedef struct inotify_event inotify_event;
typedef inotify_event* inotify_event_ptr;
static bool forkmon_track_file_open(char* name);
typedef struct NELUA_MAYALIAS nlcchar_arr4097 {char v[4097];} nlcchar_arr4097;
typedef union NELUA_MAYALIAS nlcchar_arr4097_cast {nlcchar_arr4097 a; char p[4097];} nlcchar_arr4097_cast;
static void forkmon_signal_handler(int signum);
static void forkmon_parse_env(void);
static char nelua_strlit_2[102] = "the environment variable FORKMON_FILTER is not set, please set one (example FORKMON_FILTER=\"%.lua$\")\n";
NELUA_CEXPORT FILE_ptr fopen(const char* __restrict filename, const char* __restrict mode);
NELUA_CEXPORT FILE_ptr fopen64(const char* __restrict filename, const char* __restrict mode);
NELUA_CEXPORT int open(const char* __restrict path, int flags, ...);
void __attribute__((constructor)) setup(void);
typedef char** nlcstring_ptr;
static int nelua_main(int argc, char** argv);
/* ------------------------------ DEFINITIONS ------------------------------- */
void sys_usleep(uint64_t ms) {
  timespec ts = {0};
  ts.tv_sec = (long)(ms / 1000000);
  ts.tv_nsec = (long)((ms % 1000000) * 1000);
  nanosleep((&ts), ((timespec_ptr)NULL));
}
uint64_t sys_uticks(void) {
  timespec ts = {0};
  clock_gettime(1, (&ts));
  return (uint64_t)((ts.tv_sec * 1000000) + (ts.tv_nsec / 1000));
}
int sys_killwait(int pid, int sig) {
  kill(pid, sig);
  return waitpid(pid, (nlcint_ptr)NULL, 0);
}
bool sys_filexists(const char* path) {
  return (access(path, F_OK) == 0);
}
nlstring sys_resolvpath(char* path, char* buf, int len) {
  if(((((intptr_t)strlen(path)) < len) && (realpath(path, buf) != NULL))) {
    return (nlstring){((nluint8_arr0_ptr)buf), (uintptr_t)((intptr_t)strlen(buf))};
  }
  return (nlstring){0};
}
void nelua_memory_copy(void* dest, void* src, uintptr_t n) {
  if(NELUA_UNLIKELY((n == 0))) {
    return;
  }
  memcpy(dest, src, (size_t)n);
}
void nelua_memory_zero(void* dest, uintptr_t n) {
  if(NELUA_UNLIKELY((n == 0))) {
    return;
  }
  memset(dest, 0, (size_t)n);
}
int32_t nelua_memory_compare(void* a, void* b, uintptr_t n) {
  if(NELUA_UNLIKELY((n == 0))) {
    return 0;
  }
  return (int32_t)memcmp(a, b, (size_t)n);
}
bool nelua_memory_equals(void* a, void* b, uintptr_t n) {
  if(NELUA_UNLIKELY((n == 0))) {
    return true;
  }
  return (memcmp(a, b, (size_t)n) == 0);
}
void* nelua_memory_scan(void* src, uint8_t x, uintptr_t n) {
  if(NELUA_UNLIKELY((n == 0))) {
    return (void*)NULL;
  }
  return memchr(src, (int)x, (size_t)n);
}
void* nelua_memory_find(void* haystack, uintptr_t haystacksize, void* needle, uintptr_t needlesize) {
  if(NELUA_UNLIKELY(((needlesize == 0) || (haystack == needle)))) {
    return haystack;
  } else if(NELUA_UNLIKELY((needlesize > haystacksize))) {
    return (void*)NULL;
  } else {
    if((needlesize == 1)) {
      return memchr(haystack, (int)(*(nluint8_ptr)needle), (size_t)haystacksize);
    }
    uintptr_t haystackbegin = (uintptr_t)haystack;
    for(uintptr_t i = haystackbegin, _end = (haystackbegin + (haystacksize - needlesize)); i <= _end; i = i + 1) {
      void* p = (void*)i;
      if((memcmp(p, needle, (size_t)needlesize) == 0)) {
        return p;
      }
    }
    return (void*)NULL;
  }
}
bool nelua_span_uint8__empty(nelua_span_uint8__ptr self) {
  return (self->size == 0);
}
nluint8_ptr nelua_span_uint8____atindex(nelua_span_uint8__ptr self, uintptr_t i) {
  return (&self->data[i]);
}
nlusize_ptr nelua_span_usize____atindex(nelua_span_usize__ptr self, uintptr_t i) {
  return (&self->data[i]);
}
nelua_hashmapnode_string__boolean__ptr nelua_span_hashmapnode_string__boolean_____atindex(nelua_span_hashmapnode_string__boolean___ptr self, uintptr_t i) {
  return (&self->data[i]);
}
void nelua_memory_spanset_1(nelua_span_usize_ dest, uintptr_t x) {
  for(uintptr_t i = 0U, _end = dest.size; i < _end; i = i + 1) {
    memcpy((void*)(&(*nelua_span_usize____atindex((&dest), i))), (void*)(&x), 8U);
  }
}
void* nelua_GeneralAllocator_alloc(nelua_GeneralAllocator_ptr self, uintptr_t size) {
  if(NELUA_UNLIKELY((size == 0))) {
    return (void*)NULL;
  }
  return malloc((size_t)size);
}
void* nelua_GeneralAllocator_alloc0(nelua_GeneralAllocator_ptr self, uintptr_t size) {
  if(NELUA_UNLIKELY((size == 0))) {
    return (void*)NULL;
  }
  return calloc((size_t)size, 1U);
}
void nelua_GeneralAllocator_dealloc(nelua_GeneralAllocator_ptr self, void* p) {
  if(NELUA_UNLIKELY((p == (void*)NULL))) {
    return;
  }
  free(p);
}
void* nelua_GeneralAllocator_realloc(nelua_GeneralAllocator_ptr self, void* p, uintptr_t newsize, uintptr_t oldsize) {
  if(NELUA_UNLIKELY((newsize == 0))) {
    if(NELUA_LIKELY((p != (void*)NULL))) {
      free(p);
    }
    return (void*)NULL;
  } else if(NELUA_UNLIKELY((newsize == oldsize))) {
    return p;
  }
  return realloc(p, (size_t)newsize);
}
void nelua_write_stderr(const char* msg, uintptr_t len, bool flush) {
  if(len > 0 && msg) {
    fwrite(msg, 1, len, stderr);
  }
  if(flush) {
    fwrite("\n", 1, 1, stderr);
    fflush(stderr);
  }
}
void nelua_abort(void) {
  NELUA_UBSAN_UNREACHABLE();
  abort();
}
void nelua_panic_string(nlstring s) {
  if(s.size > 0) {
    nelua_write_stderr((const char*)s.data, s.size, true);
  }
  nelua_abort();
}
void* nelua_GeneralAllocator_xalloc(nelua_GeneralAllocator_ptr self, uintptr_t size) {
  void* p = nelua_GeneralAllocator_alloc(self, size);
  if(NELUA_UNLIKELY(((p == (void*)NULL) && (size > 0)))) {
    nelua_panic_string(((nlstring){(uint8_t*)"out of memory", 13}));
  }
  return p;
}
void* nelua_GeneralAllocator_realloc0(nelua_GeneralAllocator_ptr self, void* p, uintptr_t newsize, uintptr_t oldsize) {
  p = nelua_GeneralAllocator_realloc(self, p, newsize, oldsize);
  if(NELUA_LIKELY(((newsize > oldsize) && (p != (void*)NULL)))) {
    nelua_memory_zero((void*)(&((nluint8_arr0_ptr)p)[oldsize]), (newsize - oldsize));
  }
  return p;
}
nelua_span_usize_ nelua_GeneralAllocator_spanalloc_3(nelua_GeneralAllocator_ptr self, nlniltype T, uintptr_t size) {
  if(NELUA_LIKELY((size > 0))) {
    nlusize_arr0_ptr data = ((nlusize_arr0_ptr)nelua_GeneralAllocator_alloc(self, (size * 8)));
    if(NELUA_LIKELY((data != ((nlusize_arr0_ptr)NULL)))) {
      return (nelua_span_usize_){data, size};
    }
  }
  return (nelua_span_usize_){0};
}
nelua_span_uint8_ nelua_GeneralAllocator_spanalloc0_1(nelua_GeneralAllocator_ptr self, nlniltype T, uintptr_t size) {
  if(NELUA_LIKELY((size > 0))) {
    nluint8_arr0_ptr data = ((nluint8_arr0_ptr)nelua_GeneralAllocator_alloc0(self, (size * 1)));
    if(NELUA_LIKELY((data != ((nluint8_arr0_ptr)NULL)))) {
      return (nelua_span_uint8_){data, size};
    }
  }
  return (nelua_span_uint8_){0};
}
nelua_span_hashmapnode_string__boolean__ nelua_GeneralAllocator_spanalloc0_2(nelua_GeneralAllocator_ptr self, nlniltype T, uintptr_t size) {
  if(NELUA_LIKELY((size > 0))) {
    nelua_hashmapnode_string__boolean__arr0_ptr data = ((nelua_hashmapnode_string__boolean__arr0_ptr)nelua_GeneralAllocator_alloc0(self, (size * 32)));
    if(NELUA_LIKELY((data != ((nelua_hashmapnode_string__boolean__arr0_ptr)NULL)))) {
      return (nelua_span_hashmapnode_string__boolean__){data, size};
    }
  }
  return (nelua_span_hashmapnode_string__boolean__){0};
}
void nelua_GeneralAllocator_spandealloc_1(nelua_GeneralAllocator_ptr self, nelua_span_uint8_ s) {
  if(NELUA_UNLIKELY((s.size == 0))) {
    return;
  }
  nelua_GeneralAllocator_dealloc(self, (void*)s.data);
}
nelua_span_usize_ nelua_GeneralAllocator_spanrealloc_3(nelua_GeneralAllocator_ptr self, nelua_span_usize_ s, uintptr_t size) {
  if(NELUA_UNLIKELY(((s.size == 0) && (size > 0)))) {
    s = nelua_GeneralAllocator_spanalloc_3(self, NELUA_NIL, size);
    return s;
  }
  nlusize_arr0_ptr p = ((nlusize_arr0_ptr)nelua_GeneralAllocator_realloc(self, (void*)s.data, (size * 8), (s.size * 8)));
  if(NELUA_UNLIKELY(((size > 0) && (p == ((nlusize_arr0_ptr)NULL))))) {
    return s;
  }
  s.data = p;
  s.size = size;
  return s;
}
nelua_span_usize_ nelua_GeneralAllocator_xspanrealloc_3(nelua_GeneralAllocator_ptr self, nelua_span_usize_ s, uintptr_t size) {
  s = nelua_GeneralAllocator_spanrealloc_3(self, s, size);
  if(NELUA_UNLIKELY((s.size != size))) {
    nelua_panic_string(((nlstring){(uint8_t*)"out of memory", 13}));
  }
  return s;
}
nelua_span_uint8_ nelua_GeneralAllocator_spanrealloc0_1(nelua_GeneralAllocator_ptr self, nelua_span_uint8_ s, uintptr_t size) {
  if(NELUA_UNLIKELY(((s.size == 0) && (size > 0)))) {
    s = nelua_GeneralAllocator_spanalloc0_1(self, NELUA_NIL, size);
    return s;
  }
  nluint8_arr0_ptr p = ((nluint8_arr0_ptr)nelua_GeneralAllocator_realloc0(self, (void*)s.data, (size * 1), (s.size * 1)));
  if(NELUA_UNLIKELY(((size > 0) && (p == ((nluint8_arr0_ptr)NULL))))) {
    return s;
  }
  s.data = p;
  s.size = size;
  return s;
}
nelua_span_hashmapnode_string__boolean__ nelua_GeneralAllocator_spanrealloc0_2(nelua_GeneralAllocator_ptr self, nelua_span_hashmapnode_string__boolean__ s, uintptr_t size) {
  if(NELUA_UNLIKELY(((s.size == 0) && (size > 0)))) {
    s = nelua_GeneralAllocator_spanalloc0_2(self, NELUA_NIL, size);
    return s;
  }
  nelua_hashmapnode_string__boolean__arr0_ptr p = ((nelua_hashmapnode_string__boolean__arr0_ptr)nelua_GeneralAllocator_realloc0(self, (void*)s.data, (size * 32), (s.size * 32)));
  if(NELUA_UNLIKELY(((size > 0) && (p == ((nelua_hashmapnode_string__boolean__arr0_ptr)NULL))))) {
    return s;
  }
  s.data = p;
  s.size = size;
  return s;
}
nelua_span_hashmapnode_string__boolean__ nelua_GeneralAllocator_xspanrealloc0_1(nelua_GeneralAllocator_ptr self, nelua_span_hashmapnode_string__boolean__ s, uintptr_t size) {
  s = nelua_GeneralAllocator_spanrealloc0_2(self, s, size);
  if(NELUA_UNLIKELY((s.size != size))) {
    nelua_panic_string(((nlstring){(uint8_t*)"out of memory", 13}));
  }
  return s;
}
bool nelua_strchar_1_isalpha(uint8_t c) {
  return ((((uint32_t)c | 32) - 97U) < 26);
}
bool nelua_strchar_1_islower(uint8_t c) {
  return (((uint32_t)c - 97U) < 26);
}
bool nelua_strchar_1_isupper(uint8_t c) {
  return (((uint32_t)c - 65U) < 26);
}
bool nelua_strchar_1_isdigit(uint8_t c) {
  return (((uint32_t)c - 48U) < 10);
}
bool nelua_strchar_1_isxdigit(uint8_t c) {
  return (nelua_strchar_1_isdigit(c) || ((((uint32_t)c | 32) - 97U) < 6));
}
bool nelua_strchar_1_iscntrl(uint8_t c) {
  return (((uint32_t)c < 0x20) || (c == 0x7f));
}
bool nelua_strchar_1_isgraph(uint8_t c) {
  return (((uint32_t)c - 0x21) < 0x5e);
}
bool nelua_strchar_1_isspace(uint8_t c) {
  return ((c == 32U) || (((uint32_t)c - 9U) < 5));
}
bool nelua_strchar_1_isalnum(uint8_t c) {
  return (nelua_strchar_1_isalpha(c) || nelua_strchar_1_isdigit(c));
}
bool nelua_strchar_1_ispunct(uint8_t c) {
  return (nelua_strchar_1_isgraph(c) && (!nelua_strchar_1_isalnum(c)));
}
uint8_t nelua_strchar_1_getbasedigit(uint8_t c) {
  uint8_t d = (c - 48U);
  if((d < 10)) {
    return d;
  }
  d = (c - 97U);
  if((d < 26)) {
    return (d + 10);
  }
  d = (c - 65U);
  if((d < 26)) {
    return (d + 10);
  }
  return 255U;
}
void nelua_assert_line_1(bool cond, nlstring msg) {
  if(NELUA_UNLIKELY(!cond)) {
    nelua_write_stderr("/home/bart/projects/nelua/nelua-lang/lib/stringbuilder.nelua\033[1m:28:12: \033[31m\033[1mruntime error: \033[0m\033[1m", 104, false);
    nelua_write_stderr((const char*)msg.data, msg.size, false);
    nelua_write_stderr("\033[0m\n  assert(p < L_FMTFLAGS.size + 1, \"invalid format (repeated flags)\")\n           \033[1m\033[32m^\033[0m\033[35m~~~~~~~~~~~~~~~~~~~~\033[0m\n", 129, true);
    nelua_abort();
  }
}
void nelua_assert_line_2(bool cond, nlstring msg) {
  if(NELUA_UNLIKELY(!cond)) {
    nelua_write_stderr("/home/bart/projects/nelua/nelua-lang/lib/stringbuilder.nelua\033[1m:36:10: \033[31m\033[1mruntime error: \033[0m\033[1m", 104, false);
    nelua_write_stderr((const char*)msg.data, msg.size, false);
    nelua_write_stderr("\033[0m\n  assert(not strchar.isdigit(strfmt[p]), \"invalid format (width or precision too long)\")\n         \033[1m\033[32m^\033[0m\033[35m~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\033[0m\n", 156, true);
    nelua_abort();
  }
}
uintptr_t nelua_scanformat(nluint8_arr0_ptr strfmt, nluint8_arr32_ptr form) {
  uintptr_t p = 0U;
  while(((strfmt[p] != 0) && (nelua_memory_scan((void*)((nlstring){(uint8_t*)"-+ #0", 5}).data, strfmt[p], 5U) != (void*)NULL))) {
    p = (p + 1);
  }
  nelua_assert_line_1((p < (((nlstring){(uint8_t*)"-+ #0", 5}).size + 1)), ((nlstring){(uint8_t*)"invalid format (repeated flags)", 31}));
  if(nelua_strchar_1_isdigit(strfmt[p])) {
    p = (p + 1);
  }
  if(nelua_strchar_1_isdigit(strfmt[p])) {
    p = (p + 1);
  }
  if((strfmt[p] == 46U)) {
    p = (p + 1);
    if(nelua_strchar_1_isdigit(strfmt[p])) {
      p = (p + 1);
    }
    if(nelua_strchar_1_isdigit(strfmt[p])) {
      p = (p + 1);
    }
  }
  nelua_assert_line_2((!nelua_strchar_1_isdigit(strfmt[p])), ((nlstring){(uint8_t*)"invalid format (width or precision too long)", 44}));
  form->v[0] = 37U;
  nelua_memory_copy((void*)(&form->v[1]), (void*)(&strfmt[0]), (p + 1));
  form->v[(p + 2)] = 0U;
  return p;
}
void nelua_stringbuilderT_destroy(nelua_stringbuilderT_ptr self) {
  nelua_GeneralAllocator_spandealloc_1((&self->allocator), self->data);
  self->data = (nelua_span_uint8_){0};
  self->size = 0U;
}
bool nelua_stringbuilderT_grow(nelua_stringbuilderT_ptr self, uintptr_t newsize) {
  uintptr_t needed = (newsize + 1);
  uintptr_t cap = self->data.size;
  if((needed <= cap)) {
    return true;
  }
  if((cap == 0)) {
    cap = 16U;
  }
  while((cap < needed)) {
    cap = (cap * 2);
    if((cap <= 16U)) {
      return false;
    }
  }
  self->data = nelua_GeneralAllocator_spanrealloc0_1((&self->allocator), self->data, cap);
  if((self->data.size != cap)) {
    self->data = nelua_GeneralAllocator_spanrealloc0_1((&self->allocator), self->data, needed);
  }
  return (needed <= self->data.size);
}
nelua_span_uint8_ nelua_stringbuilderT_prepare(nelua_stringbuilderT_ptr self, uintptr_t n) {
  if((!nelua_stringbuilderT_grow(self, (self->size + n)))) {
    return (nelua_span_uint8_){0};
  }
  return (nelua_span_uint8_){.data = ((nluint8_arr0_ptr)(&(*nelua_span_uint8____atindex((&self->data), self->size)))), .size = ((self->data.size - self->size) - 1)};
}
void nelua_stringbuilderT_commit(nelua_stringbuilderT_ptr self, uintptr_t n) {
  uintptr_t newsize = (self->size + n);
  self->size = newsize;
}
bool nelua_stringbuilderT_writebyte_1(nelua_stringbuilderT_ptr self, uint8_t c, nlniltype n) {
  nelua_span_uint8_ p = nelua_stringbuilderT_prepare(self, 1U);
  if(NELUA_UNLIKELY(nelua_span_uint8__empty((&p)))) {
    return false;
  }
  p.data[0] = c;
  self->size = (self->size + 1);
  return true;
}
void nelua_assert_line_3(bool cond, nlstring msg) {
  if(NELUA_UNLIKELY(!cond)) {
    nelua_write_stderr("/home/bart/projects/nelua/nelua-lang/lib/stringbuilder.nelua\033[1m:344:12: \033[31m\033[1mruntime error: \033[0m\033[1m", 105, false);
    nelua_write_stderr((const char*)msg.data, msg.size, false);
    nelua_write_stderr("\033[0m\n    assert(false, 'invalid format for argument')\n           \033[1m\033[32m^\033[0m\033[35m~~~~\033[0m\n", 93, true);
    nelua_abort();
  }
}
void nelua_assert_line_4(bool cond, nlstring msg) {
  if(NELUA_UNLIKELY(!cond)) {
    nelua_write_stderr("/home/bart/projects/nelua/nelua-lang/lib/stringbuilder.nelua\033[1m:346:15: \033[31m\033[1mruntime error: \033[0m\033[1m", 105, false);
    nelua_write_stderr((const char*)msg.data, msg.size, false);
    nelua_write_stderr("\033[0m\n    assert(nb >= 0, 'unexpected number of bytes written in sprintf')\n              \033[1m\033[32m^\033[0m\033[35m~~~\033[0m\n", 115, true);
    nelua_abort();
  }
}
nlmulret_nlboolean_nlisize nelua_formatarg_2(nelua_stringbuilderT_ptr self, uint8_t c, nluint8_arr32_ptr form, nlstring arg1) {
  nelua_span_uint8_ buf = nelua_stringbuilderT_prepare(self, 128U);
  if((buf.size < 128U)) {
    return (nlmulret_nlboolean_nlisize){false, 0};
  }
  intptr_t nb = -1;
  if((c == 115U)) {
    nlstring s = arg1;
    uintptr_t slen = (s.size + 1);
    if(((form->v[1] == c) && (form->v[2] == 0))) {
      buf = nelua_stringbuilderT_prepare(self, slen);
      if((buf.size < slen)) {
        return (nlmulret_nlboolean_nlisize){false, 0};
      }
      nelua_memory_copy((void*)buf.data, (void*)s.data, s.size);
      nb = (intptr_t)s.size;
    } else {
      if((slen < 128U)) {
        slen = 128U;
      }
      buf = nelua_stringbuilderT_prepare(self, slen);
      if((buf.size < slen)) {
        return (nlmulret_nlboolean_nlisize){false, 0};
      }
      s = nelua_nlstring_copy(s);
      char* cs = (char*)s.data;
      if((s.size == 0)) {
        cs = "";
      }
      nb = (intptr_t)snprintf((char*)buf.data, (size_t)buf.size, (char*)(&form->v[0]), cs);
      nelua_nlstring_destroy((&s));
    }
    goto nelua_next_5;
  }
  nelua_assert_line_3(false, ((nlstring){(uint8_t*)"invalid format for argument", 27}));
nelua_next_5:;
  nelua_assert_line_4((nb >= 0), ((nlstring){(uint8_t*)"unexpected number of bytes written in sprintf", 45}));
  return (nlmulret_nlboolean_nlisize){true, nb};
}
void nelua_assert_line_5(bool cond, nlstring msg) {
  if(NELUA_UNLIKELY(!cond)) {
    nelua_write_stderr("/home/bart/projects/nelua/nelua-lang/lib/stringbuilder.nelua\033[1m:384:18: \033[31m\033[1mruntime error: \033[0m\033[1m", 105, false);
    nelua_write_stderr((const char*)msg.data, msg.size, false);
    nelua_write_stderr("\033[0m\n          assert(false, 'bad format argument (no value)')\n                 \033[1m\033[32m^\033[0m\033[35m~~~~\033[0m\n", 108, true);
    nelua_abort();
  }
}
nlmulret_nlboolean_nlusize nelua_stringbuilderT_writef_2(nelua_stringbuilderT_ptr self, nlstring fmt, nlstring __arg1) {
  uintptr_t pos = 0U;
  uintptr_t written = 0U;
  int32_t argi = 0;
  while((pos < fmt.size)) {
    uint8_t c = fmt.data[pos];
    pos = (pos + 1);
    if((c != 37U)) {
      if((!nelua_stringbuilderT_writebyte_1(self, c, NELUA_NIL))) {
        return (nlmulret_nlboolean_nlusize){false, written};
      }
      written = (written + 1);
    } else {
      c = fmt.data[pos];
      if((c == 37U)) {
        if((!nelua_stringbuilderT_writebyte_1(self, 37U, NELUA_NIL))) {
          return (nlmulret_nlboolean_nlusize){false, written};
        }
        written = (written + 1);
        pos = (pos + 1);
      } else {
        nluint8_arr32 form = {0};
        pos = (pos + nelua_scanformat(((nluint8_arr0_ptr)(&fmt.data[pos])), (&form)));
        c = fmt.data[pos];
        pos = (pos + 1);
        argi = (argi + 1);
        bool ok = false;
        intptr_t nb = -1;
        if((1 == argi)) {
          nlmulret_nlboolean_nlisize _asgnret_1 = nelua_formatarg_2(self, c, (&form), __arg1);
          ok = _asgnret_1.r1;
          nb = _asgnret_1.r2;
          goto nelua_next_3;
        }
        nelua_assert_line_5(false, ((nlstring){(uint8_t*)"bad format argument (no value)", 30}));
nelua_next_3:;
        if((!ok)) {
          return (nlmulret_nlboolean_nlusize){false, written};
        }
        nelua_stringbuilderT_commit(self, (uintptr_t)nb);
        written = (written + (uintptr_t)nb);
      }
    }
  }
  return (nlmulret_nlboolean_nlusize){true, written};
}
void nelua_assert_line_6(bool cond, nlstring msg) {
  if(NELUA_UNLIKELY(!cond)) {
    nelua_write_stderr("/home/bart/projects/nelua/nelua-lang/lib/stringbuilder.nelua\033[1m:384:18: \033[31m\033[1mruntime error: \033[0m\033[1m", 105, false);
    nelua_write_stderr((const char*)msg.data, msg.size, false);
    nelua_write_stderr("\033[0m\n          assert(false, 'bad format argument (no value)')\n                 \033[1m\033[32m^\033[0m\033[35m~~~~\033[0m\n", 108, true);
    nelua_abort();
  }
}
nlmulret_nlboolean_nlusize nelua_stringbuilderT_writef_3(nelua_stringbuilderT_ptr self, nlstring fmt) {
  uintptr_t pos = 0U;
  uintptr_t written = 0U;
  int32_t argi = 0;
  while((pos < fmt.size)) {
    uint8_t c = fmt.data[pos];
    pos = (pos + 1);
    if((c != 37U)) {
      if((!nelua_stringbuilderT_writebyte_1(self, c, NELUA_NIL))) {
        return (nlmulret_nlboolean_nlusize){false, written};
      }
      written = (written + 1);
    } else {
      c = fmt.data[pos];
      if((c == 37U)) {
        if((!nelua_stringbuilderT_writebyte_1(self, 37U, NELUA_NIL))) {
          return (nlmulret_nlboolean_nlusize){false, written};
        }
        written = (written + 1);
        pos = (pos + 1);
      } else {
        nluint8_arr32 form = {0};
        pos = (pos + nelua_scanformat(((nluint8_arr0_ptr)(&fmt.data[pos])), (&form)));
        c = fmt.data[pos];
        pos = (pos + 1);
        argi = (argi + 1);
        bool ok = false;
        intptr_t nb = -1;
        nelua_assert_line_6(false, ((nlstring){(uint8_t*)"bad format argument (no value)", 30}));
        if((!ok)) {
          return (nlmulret_nlboolean_nlusize){false, written};
        }
        nelua_stringbuilderT_commit(self, (uintptr_t)nb);
        written = (written + (uintptr_t)nb);
      }
    }
  }
  return (nlmulret_nlboolean_nlusize){true, written};
}
nlstring nelua_stringbuilderT_view(nelua_stringbuilderT_ptr self) {
  if(NELUA_UNLIKELY((self->size == 0))) {
    return (nlstring){0};
  }
  return (nlstring){.data = ((nluint8_arr0_ptr)(&(*nelua_span_uint8____atindex((&self->data), 0U)))), .size = self->size};
}
void nelua_nlstring_destroy(nlstring_ptr self) {
  if(NELUA_UNLIKELY((self->size == 0))) {
    return;
  }
  nelua_GeneralAllocator_dealloc((&nelua_general_allocator), (void*)self->data);
  self->data = ((nluint8_arr0_ptr)NULL);
  self->size = 0U;
}
nlstring nelua_nlstring_copy(nlstring s) {
  nlstring clone = {0};
  if(NELUA_UNLIKELY((s.size == 0))) {
    return clone;
  }
  clone.data = ((nluint8_arr0_ptr)nelua_GeneralAllocator_xalloc((&nelua_general_allocator), (s.size + 1)));
  nelua_memory_copy((void*)clone.data, (void*)s.data, s.size);
  clone.data[s.size] = 0U;
  clone.size = s.size;
  return clone;
}
intptr_t nelua_nlstring___len(nlstring a) {
  return (intptr_t)a.size;
}
bool nelua_nlstring___eq(nlstring a, nlstring b) {
  return ((a.size == b.size) && (((a.data == b.data) || (a.size == 0)) || nelua_memory_equals((void*)a.data, (void*)b.data, a.size)));
}
bool nelua_StrPattCapture_is_unfinished(nelua_StrPattCapture_ptr self) {
  return (self->len == -1);
}
bool nelua_StrPattCapture_is_position(nelua_StrPattCapture_ptr self) {
  return (self->len == -2);
}
bool nelua_match_has_pattern_specials(nlstring pattern) {
  for(uintptr_t i = 0U, _end = pattern.size; i < _end; i = i + 1) {
    switch(pattern.data[i]) {
      case 94U:
      case 36U:
      case 42U:
      case 43U:
      case 63U:
      case 46U:
      case 40U:
      case 91U:
      case 37U:
      case 45U: {
        return true;
      }
    }
  }
  return false;
}
bool nelua_match_has_pattern_anchor(nlstring pattern) {
  return ((pattern.size > 0) && (pattern.data[0] == 94U));
}
nelua_StrPatt_1 nelua_StrPatt_1_create(nlstring source, nlstring pattern, bool plain) {
  if((!nelua_match_has_pattern_specials(pattern))) {
    plain = false;
  }
  bool anchor = ((!plain) && nelua_match_has_pattern_anchor(pattern));
  return (nelua_StrPatt_1){.source = source, .pattern = pattern, .plain = plain, .anchor = anchor, .depth = 32};
}
void nelua_StrPatt_1_reset_captures(nelua_StrPatt_1_ptr self) {
  for(intptr_t i = 0, _end = self->numcaptures; i < _end; i = i + 1) {
    (((nelua_StrPattCapture_arr32_cast*)&self->capture)->a).v[i] = (nelua_StrPattCapture){0};
  }
  self->numcaptures = 0;
}
nlmulret_nlboolean_nlstring_nelua_StrPattCapture nelua_StrPatt_1_get_capture(nelua_StrPatt_1_ptr self, intptr_t i) {
  if(NELUA_UNLIKELY(((i < 0) || (i >= self->numcaptures)))) {
    return (nlmulret_nlboolean_nlstring_nelua_StrPattCapture){false, ((nlstring){(uint8_t*)"invalid capture index", 21}), (nelua_StrPattCapture){0}};
  }
  if(NELUA_UNLIKELY(nelua_StrPattCapture_is_unfinished((&(((nelua_StrPattCapture_arr32_cast*)&self->capture)->a).v[i])))) {
    return (nlmulret_nlboolean_nlstring_nelua_StrPattCapture){false, ((nlstring){(uint8_t*)"unfinished capture", 18}), (nelua_StrPattCapture){0}};
  }
  nelua_StrPattCapture capture = (((nelua_StrPattCapture_arr32_cast*)&self->capture)->a).v[i];
  if((!nelua_StrPattCapture_is_position((&(((nelua_StrPattCapture_arr32_cast*)&self->capture)->a).v[i])))) {
    nlstring capstr = (nlstring){.data = ((nluint8_arr0_ptr)(&self->source.data[(((nelua_StrPattCapture_arr32_cast*)&self->capture)->a).v[i].init])), .size = (uintptr_t)(((nelua_StrPattCapture_arr32_cast*)&self->capture)->a).v[i].len};
    return (nlmulret_nlboolean_nlstring_nelua_StrPattCapture){true, capstr, capture};
  } else {
    return (nlmulret_nlboolean_nlstring_nelua_StrPattCapture){true, ((nlstring){(uint8_t*)"", 0}), capture};
  }
}
bool nelua_match_class(uint8_t c, uint8_t cl) {
  bool res = false;
  switch(cl) {
    case 97U: {
      res = nelua_strchar_1_isalpha(c);
      break;
    }
    case 65U: {
      res = (!nelua_strchar_1_isalpha(c));
      break;
    }
    case 99U: {
      res = nelua_strchar_1_iscntrl(c);
      break;
    }
    case 67U: {
      res = (!nelua_strchar_1_iscntrl(c));
      break;
    }
    case 100U: {
      res = nelua_strchar_1_isdigit(c);
      break;
    }
    case 68U: {
      res = (!nelua_strchar_1_isdigit(c));
      break;
    }
    case 103U: {
      res = nelua_strchar_1_isgraph(c);
      break;
    }
    case 71U: {
      res = (!nelua_strchar_1_isgraph(c));
      break;
    }
    case 108U: {
      res = nelua_strchar_1_islower(c);
      break;
    }
    case 76U: {
      res = (!nelua_strchar_1_islower(c));
      break;
    }
    case 112U: {
      res = nelua_strchar_1_ispunct(c);
      break;
    }
    case 80U: {
      res = (!nelua_strchar_1_ispunct(c));
      break;
    }
    case 115U: {
      res = nelua_strchar_1_isspace(c);
      break;
    }
    case 83U: {
      res = (!nelua_strchar_1_isspace(c));
      break;
    }
    case 117U: {
      res = nelua_strchar_1_isupper(c);
      break;
    }
    case 85U: {
      res = (!nelua_strchar_1_isupper(c));
      break;
    }
    case 119U: {
      res = nelua_strchar_1_isalnum(c);
      break;
    }
    case 87U: {
      res = (!nelua_strchar_1_isalnum(c));
      break;
    }
    case 120U: {
      res = nelua_strchar_1_isxdigit(c);
      break;
    }
    case 88U: {
      res = (!nelua_strchar_1_isxdigit(c));
      break;
    }
    case 122U: {
      res = (c == 0);
      break;
    }
    case 90U: {
      res = (c != 0);
      break;
    }
    default: {
      return (cl == c);
    }
  }
  return res;
}
void nelua_assert_line_7(bool cond, nlstring msg) {
  if(NELUA_UNLIKELY(!cond)) {
    nelua_write_stderr("/home/bart/projects/nelua/nelua-lang/lib/detail/strpatt.nelua\033[1m:135:16: \033[31m\033[1mruntime error: \033[0m\033[1m", 106, false);
    nelua_write_stderr((const char*)msg.data, msg.size, false);
    nelua_write_stderr("\033[0m\n      assert(p ~= #ms.pattern, \"malformed pattern (ends with '%')\")\n               \033[1m\033[32m^\033[0m\033[35m~~~~~~~~~~~~~\033[0m\n", 125, true);
    nelua_abort();
  }
}
void nelua_assert_line_8(bool cond, nlstring msg) {
  if(NELUA_UNLIKELY(!cond)) {
    nelua_write_stderr("/home/bart/projects/nelua/nelua-lang/lib/detail/strpatt.nelua\033[1m:142:18: \033[31m\033[1mruntime error: \033[0m\033[1m", 106, false);
    nelua_write_stderr((const char*)msg.data, msg.size, false);
    nelua_write_stderr("\033[0m\n        assert(p ~= #ms.pattern, \"malformed pattern (missing ']')\")\n                 \033[1m\033[32m^\033[0m\033[35m~~~~~~~~~~~~~\033[0m\n", 127, true);
    nelua_abort();
  }
}
intptr_t nelua_match_class_end(nelua_StrPatt_1_ptr ms_1, intptr_t p_1) {
  uint8_t c = ms_1->pattern.data[p_1];
  p_1 = (p_1 + 1);
  switch(c) {
    case 37U: {
      nelua_assert_line_7((p_1 != nelua_nlstring___len(ms_1->pattern)), ((nlstring){(uint8_t*)"malformed pattern (ends with '%')", 33}));
      p_1 = (p_1 + 1);
      break;
    }
    case 91U: {
      if((ms_1->pattern.data[p_1] == 94U)) {
        p_1 = (p_1 + 1);
      }
      while(1) {
        nelua_assert_line_8((p_1 != nelua_nlstring___len(ms_1->pattern)), ((nlstring){(uint8_t*)"malformed pattern (missing ']')", 31}));
        c = ms_1->pattern.data[p_1];
        p_1 = (p_1 + 1);
        if(((c == 37U) && (p_1 < nelua_nlstring___len(ms_1->pattern)))) {
          p_1 = (p_1 + 1);
        }
        if((ms_1->pattern.data[p_1] == 93U)) {
          break;
        }
      }
      p_1 = (p_1 + 1);
      break;
    }
  }
  return p_1;
}
bool nelua_match_bracket_class(nelua_StrPatt_1_ptr ms_2, uint8_t c, intptr_t p_2, intptr_t ep) {
  bool sig = true;
  if((ms_2->pattern.data[(p_2 + 1)] == 94U)) {
    sig = false;
    p_2 = (p_2 + 1);
  }
  p_2 = (p_2 + 1);
  while((p_2 < ep)) {
    if((ms_2->pattern.data[p_2] == 37U)) {
      p_2 = (p_2 + 1);
      if(nelua_match_class(c, ms_2->pattern.data[p_2])) {
        return sig;
      }
    } else if(((ms_2->pattern.data[(p_2 + 1)] == 45U) && ((p_2 + 2) < ep))) {
      p_2 = (p_2 + 2);
      if(((ms_2->pattern.data[(p_2 - 2)] <= c) && (c <= ms_2->pattern.data[p_2]))) {
        return sig;
      }
    } else if((ms_2->pattern.data[p_2] == c)) {
      return sig;
    }
    p_2 = (p_2 + 1);
  }
  return (!sig);
}
bool nelua_match_single(nelua_StrPatt_1_ptr ms_3, intptr_t s_1, intptr_t p_3, intptr_t ep) {
  if((s_1 >= nelua_nlstring___len(ms_3->source))) {
    return false;
  } else {
    uint8_t c = ms_3->source.data[s_1];
    uint8_t pc = ms_3->pattern.data[p_3];
    switch(pc) {
      case 46U: {
        return true;
      }
      case 37U: {
        return nelua_match_class(c, ms_3->pattern.data[(p_3 + 1)]);
      }
      case 91U: {
        return nelua_match_bracket_class(ms_3, c, p_3, (ep - 1));
      }
      default: {
        return (pc == c);
      }
    }
  }
}
void nelua_assert_line_9(bool cond, nlstring msg) {
  if(NELUA_UNLIKELY(!cond)) {
    nelua_write_stderr("/home/bart/projects/nelua/nelua-lang/lib/detail/strpatt.nelua\033[1m:196:14: \033[31m\033[1mruntime error: \033[0m\033[1m", 106, false);
    nelua_write_stderr((const char*)msg.data, msg.size, false);
    nelua_write_stderr("\033[0m\n    assert(p < #ms.pattern - 1, \"malformed pattern (missing arguments to '%b')\")\n             \033[1m\033[32m^\033[0m\033[35m~~~~~~~~~~~~~~~~\033[0m\n", 139, true);
    nelua_abort();
  }
}
intptr_t nelua_match_balance(nelua_StrPatt_1_ptr ms_4, intptr_t s_2, intptr_t p_4) {
  nelua_assert_line_9((p_4 < (nelua_nlstring___len(ms_4->pattern) - 1)), ((nlstring){(uint8_t*)"malformed pattern (missing arguments to '%b')", 45}));
  if(((s_2 >= nelua_nlstring___len(ms_4->source)) || (ms_4->source.data[s_2] != ms_4->pattern.data[p_4]))) {
    return -1;
  } else {
    uint8_t b = ms_4->pattern.data[p_4];
    uint8_t e = ms_4->pattern.data[(p_4 + 1)];
    intptr_t cont = 1;
    s_2 = (s_2 + 1);
    while((s_2 < nelua_nlstring___len(ms_4->source))) {
      if((ms_4->source.data[s_2] == e)) {
        cont = (cont - 1);
        if((cont == 0)) {
          return (s_2 + 1);
        }
      } else if((ms_4->source.data[s_2] == b)) {
        cont = (cont + 1);
      }
      s_2 = (s_2 + 1);
    }
  }
  return -1;
}
intptr_t nelua_match_max_expand(nelua_StrPatt_1_ptr ms_5, intptr_t s_3, intptr_t p_5, intptr_t ep) {
  intptr_t i = 0;
  while(nelua_match_single(ms_5, (s_3 + i), p_5, ep)) {
    i = (i + 1);
  }
  while((i >= 0)) {
    intptr_t res = nelua_StrPatt_1__match(ms_5, (s_3 + i), (ep + 1));
    if((res != -1)) {
      return res;
    } else {
      i = (i - 1);
    }
  }
  return -1;
}
intptr_t nelua_match_min_expand(nelua_StrPatt_1_ptr ms_6, intptr_t s_4, intptr_t p_6, intptr_t ep) {
  while(true) {
    intptr_t res = nelua_StrPatt_1__match(ms_6, s_4, (ep + 1));
    if((res != -1)) {
      return res;
    } else if(nelua_match_single(ms_6, s_4, p_6, ep)) {
      s_4 = (s_4 + 1);
    } else {
      break;
    }
  }
  return -1;
}
void nelua_assert_line_10(bool cond, nlstring msg) {
  if(NELUA_UNLIKELY(!cond)) {
    nelua_write_stderr("/home/bart/projects/nelua/nelua-lang/lib/detail/strpatt.nelua\033[1m:251:24: \033[31m\033[1mruntime error: \033[0m\033[1m", 106, false);
    nelua_write_stderr((const char*)msg.data, msg.size, false);
    nelua_write_stderr("\033[0m\n    assert(numcaptures < #ms.capture, \"too many captures\")\n                       \033[1m\033[32m^\033[0m\033[35m~~~~~~~~~~~~\033[0m\n", 123, true);
    nelua_abort();
  }
}
intptr_t nelua_match_start_capture(nelua_StrPatt_1_ptr ms_7, intptr_t s_5, intptr_t p_7, intptr_t what) {
  intptr_t numcaptures = ms_7->numcaptures;
  nelua_assert_line_10((numcaptures < 32), ((nlstring){(uint8_t*)"too many captures", 17}));
  (((nelua_StrPattCapture_arr32_cast*)&ms_7->capture)->a).v[numcaptures].init = s_5;
  (((nelua_StrPattCapture_arr32_cast*)&ms_7->capture)->a).v[numcaptures].len = what;
  ms_7->numcaptures = (numcaptures + 1);
  intptr_t res = nelua_StrPatt_1__match(ms_7, s_5, p_7);
  if((res == -1)) {
    (((nelua_StrPattCapture_arr32_cast*)&ms_7->capture)->a).v[numcaptures] = (nelua_StrPattCapture){0};
    ms_7->numcaptures = (ms_7->numcaptures - 1);
  }
  return res;
}
void nelua_assert_line_11(bool cond, nlstring msg) {
  if(NELUA_UNLIKELY(!cond)) {
    nelua_write_stderr("/home/bart/projects/nelua/nelua-lang/lib/detail/strpatt.nelua\033[1m:271:14: \033[31m\033[1mruntime error: \033[0m\033[1m", 106, false);
    nelua_write_stderr((const char*)msg.data, msg.size, false);
    nelua_write_stderr("\033[0m\n    assert(l ~= -1, \"invalid pattern capture\")\n             \033[1m\033[32m^\033[0m\033[35m~~~~\033[0m\n", 93, true);
    nelua_abort();
  }
}
intptr_t nelua_match_end_capture(nelua_StrPatt_1_ptr ms_8, intptr_t s_6, intptr_t p_8) {
  intptr_t l = -1;
  for(intptr_t numcaptures = (ms_8->numcaptures - 1); numcaptures >= 0; numcaptures = numcaptures + -1) {
    if(((((nelua_StrPattCapture_arr32_cast*)&ms_8->capture)->a).v[numcaptures].len == -1)) {
      l = numcaptures;
      break;
    }
  }
  nelua_assert_line_11((l != -1), ((nlstring){(uint8_t*)"invalid pattern capture", 23}));
  (((nelua_StrPattCapture_arr32_cast*)&ms_8->capture)->a).v[l].len = (s_6 - (((nelua_StrPattCapture_arr32_cast*)&ms_8->capture)->a).v[l].init);
  intptr_t res = nelua_StrPatt_1__match(ms_8, s_6, p_8);
  if((res == -1)) {
    (((nelua_StrPattCapture_arr32_cast*)&ms_8->capture)->a).v[l].len = -1;
  }
  return res;
}
void nelua_assert_line_12(bool cond, nlstring msg) {
  if(NELUA_UNLIKELY(!cond)) {
    nelua_write_stderr("/home/bart/projects/nelua/nelua-lang/lib/detail/strpatt.nelua\033[1m:282:42: \033[31m\033[1mruntime error: \033[0m\033[1m", 106, false);
    nelua_write_stderr((const char*)msg.data, msg.size, false);
    nelua_write_stderr("\033[0m\n    assert(l >= 0 and l < ms.numcaptures and ms.capture[l].len ~= CAP_UNFINISHED, \"invalid capture index\")\n                                         \033[1m\033[32m^\033[0m\033[35m~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\033[0m\n", 215, true);
    nelua_abort();
  }
}
intptr_t nelua_match_capture(nelua_StrPatt_1_ptr ms_9, intptr_t s_7, intptr_t l) {
  l = (intptr_t)(l - 49U);
  nelua_assert_line_12((((l >= 0) && (l < ms_9->numcaptures)) && ((((nelua_StrPattCapture_arr32_cast*)&ms_9->capture)->a).v[l].len != -1)), ((nlstring){(uint8_t*)"invalid capture index", 21}));
  uintptr_t len = (uintptr_t)(((nelua_StrPattCapture_arr32_cast*)&ms_9->capture)->a).v[l].len;
  if((((uintptr_t)(nelua_nlstring___len(ms_9->source) - s_7) >= len) && (nelua_memory_compare((void*)(&ms_9->source.data[(((nelua_StrPattCapture_arr32_cast*)&ms_9->capture)->a).v[l].init]), (void*)(&ms_9->source.data[s_7]), len) == 0))) {
    return (intptr_t)(int64_t)(s_7 + len);
  }
  return -1;
}
void nelua_assert_line_13(bool cond, nlstring msg) {
  if(NELUA_UNLIKELY(!cond)) {
    nelua_write_stderr("/home/bart/projects/nelua/nelua-lang/lib/detail/strpatt.nelua\033[1m:292:19: \033[31m\033[1mruntime error: \033[0m\033[1m", 106, false);
    nelua_write_stderr((const char*)msg.data, msg.size, false);
    nelua_write_stderr("\033[0m\n  assert(ms.depth > 0, 'pattern too complex')\n                  \033[1m\033[32m^\033[0m\033[35m~~\033[0m\n", 95, true);
    nelua_abort();
  }
}
void nelua_assert_line_14(bool cond, nlstring msg) {
  if(NELUA_UNLIKELY(!cond)) {
    nelua_write_stderr("/home/bart/projects/nelua/nelua-lang/lib/detail/strpatt.nelua\033[1m:324:35: \033[31m\033[1mruntime error: \033[0m\033[1m", 106, false);
    nelua_write_stderr((const char*)msg.data, msg.size, false);
    nelua_write_stderr("\033[0m\n        assert(ms.pattern.data[p] == '['_b, \"missing '[' after '%f' in pattern\")\n                                  \033[1m\033[32m^\033[0m\033[35m~~~~~~~\033[0m\n", 151, true);
    nelua_abort();
  }
}
intptr_t nelua_StrPatt_1__match(nelua_StrPatt_1_ptr ms, intptr_t s, intptr_t p) {
  ms->depth = (ms->depth - 1);
  nelua_assert_line_13((ms->depth > 0), ((nlstring){(uint8_t*)"pattern too complex", 19}));
  while((p < nelua_nlstring___len(ms->pattern))) {
    switch(ms->pattern.data[p]) {
      case 40U: {
        if((ms->pattern.data[(p + 1)] == 41U)) {
          s = nelua_match_start_capture(ms, s, (p + 2), -2);
        } else {
          s = nelua_match_start_capture(ms, s, (p + 1), -1);
        }
        goto _breaklabel_1;
      }
      case 41U: {
        s = nelua_match_end_capture(ms, s, (p + 1));
        goto _breaklabel_1;
      }
      case 36U: {
        if(((p + 1) == nelua_nlstring___len(ms->pattern))) {
          if((s != nelua_nlstring___len(ms->source))) {
            s = -1;
          }
          goto _breaklabel_1;
        }
        break;
      }
      case 37U: {
        switch(ms->pattern.data[(p + 1)]) {
          case 98U: {
            s = nelua_match_balance(ms, s, (p + 2));
            if((s != -1)) {
              p = (p + 4);
              continue;
            }
            goto _breaklabel_1;
          }
          case 102U: {
            p = (p + 2);
            nelua_assert_line_14((ms->pattern.data[p] == 91U), ((nlstring){(uint8_t*)"missing '[' after '%f' in pattern", 33}));
            intptr_t ep = nelua_match_class_end(ms, p);
            uint8_t previous = (((s == 0) && (s < nelua_nlstring___len(ms->source))) ? 0x0U : ms->source.data[(s - 1)]);
            uint8_t next_1 = ((s == nelua_nlstring___len(ms->source)) ? 0x0U : ms->source.data[s]);
            if(((!nelua_match_bracket_class(ms, previous, p, (ep - 1))) && nelua_match_bracket_class(ms, next_1, p, (ep - 1)))) {
              p = ep;
              continue;
            }
            s = -1;
            goto _breaklabel_1;
          }
          case 48U:
          case 49U:
          case 50U:
          case 51U:
          case 52U:
          case 53U:
          case 54U:
          case 55U:
          case 56U:
          case 57U: {
            s = nelua_match_capture(ms, s, (intptr_t)ms->pattern.data[(p + 1)]);
            if((s != -1)) {
              p = (p + 2);
              continue;
            }
            goto _breaklabel_1;
          }
        }
        break;
      }
    }
    {
      intptr_t ep = nelua_match_class_end(ms, p);
      uint8_t epc = ms->pattern.data[ep];
      if((!nelua_match_single(ms, s, p, ep))) {
        if((((epc == 42U) || (epc == 63U)) || (epc == 45U))) {
          p = (ep + 1);
          continue;
        } else {
          s = -1;
        }
      } else {
        switch(epc) {
          case 63U: {
            intptr_t res = nelua_StrPatt_1__match(ms, (s + 1), (ep + 1));
            if((res != -1)) {
              s = res;
            } else {
              p = (ep + 1);
              continue;
            }
            break;
          }
          case 43U: {
            s = (s + 1);
            s = nelua_match_max_expand(ms, s, p, ep);
            break;
          }
          case 42U: {
            s = nelua_match_max_expand(ms, s, p, ep);
            break;
          }
          case 45U: {
            s = nelua_match_min_expand(ms, s, p, ep);
            break;
          }
          default: {
            s = (s + 1);
            p = ep;
            continue;
          }
        }
      }
      break;
    }
  }
  _breaklabel_1:;
  ms->depth = (ms->depth + 1);
  return s;
}
nlmulret_nlisize_nlisize nelua_StrPatt_1_match(nelua_StrPatt_1_ptr ms, intptr_t s) {
  if(((uintptr_t)s > ms->source.size)) {
    return (nlmulret_nlisize_nlisize){s, -1};
  } else if((ms->pattern.size == 0)) {
    return (nlmulret_nlisize_nlisize){s, s};
  } else if(ms->plain) {
    void* found = nelua_memory_find((void*)(&ms->source.data[s]), (ms->source.size - (uintptr_t)s), (void*)(&ms->pattern.data[0]), ms->pattern.size);
    if((!(found != NULL))) {
      return (nlmulret_nlisize_nlisize){s, -1};
    } else {
      s = (intptr_t)((uintptr_t)found - (uintptr_t)(&ms->source.data[0]));
      return (nlmulret_nlisize_nlisize){s, (intptr_t)(int64_t)(s + ms->pattern.size)};
    }
  } else {
    intptr_t p = 0;
    if(ms->anchor) {
      p = 1;
    }
    while(1) {
      nelua_StrPatt_1_reset_captures(ms);
      intptr_t e = nelua_StrPatt_1__match(ms, s, p);
      if((e != -1)) {
        return (nlmulret_nlisize_nlisize){s, e};
      }
      s = (s + 1);
      if(((s > nelua_nlstring___len(ms->source)) || ms->anchor)) {
        break;
      }
    }
    return (nlmulret_nlisize_nlisize){s, -1};
  }
}
nlmulret_nlisize_nlisize nelua_nlstring_find_1(nlstring s, nlstring pattern, nlniltype init, nlniltype plain) {
  intptr_t init_1 = 1;
  bool plain_1 = false;
  nelua_StrPatt_1 ms = nelua_StrPatt_1_create(s, pattern, plain_1);
  nlmulret_nlisize_nlisize _asgnret_1 = nelua_StrPatt_1_match((&ms), (init_1 - 1));
  intptr_t startpos = _asgnret_1.r1;
  intptr_t endpos = _asgnret_1.r2;
  if((endpos != -1)) {
    return (nlmulret_nlisize_nlisize){(startpos + 1), endpos};
  } else {
    return (nlmulret_nlisize_nlisize){0, 0};
  }
}
void nelua_assert_line_15(bool cond, nlstring msg) {
  if(NELUA_UNLIKELY(!cond)) {
    nelua_write_stderr("/home/bart/projects/nelua/nelua-lang/lib/string.nelua\033[1m:615:35: \033[31m\033[1mruntime error: \033[0m\033[1m", 98, false);
    nelua_write_stderr((const char*)msg.data, msg.size, false);
    nelua_write_stderr("\033[0m\n      assert(state.ms.numcaptures <= MAX_CAPTURES, 'too many captures')\n                                  \033[1m\033[32m^\033[0m\033[35m~~~~~~~~~~~~~~\033[0m\n", 149, true);
    nelua_abort();
  }
}
void nelua_assert_line_16(bool cond, nlstring msg) {
  if(NELUA_UNLIKELY(!cond)) {
    nelua_write_stderr("/home/bart/projects/nelua/nelua-lang/lib/string.nelua\033[1m:618:16: \033[31m\033[1mruntime error: \033[0m\033[1m", 98, false);
    nelua_write_stderr((const char*)msg.data, msg.size, false);
    nelua_write_stderr("\033[0m\n        assert(ok, capstr)\n               \033[1m\033[32m^\033[0m\033[35m~\033[0m\n", 72, true);
    nelua_abort();
  }
}
void nelua_assert_line_17(bool cond, nlstring msg) {
  if(NELUA_UNLIKELY(!cond)) {
    nelua_write_stderr("/home/bart/projects/nelua/nelua-lang/lib/string.nelua\033[1m:619:16: \033[31m\033[1mruntime error: \033[0m\033[1m", 98, false);
    nelua_write_stderr((const char*)msg.data, msg.size, false);
    nelua_write_stderr("\033[0m\n        assert(not capture:is_position(), 'position capture not supported yet')\n               \033[1m\033[32m^\033[0m\033[35m~~~~~~~~~~~~~~~~~~~~~~~~\033[0m\n", 148, true);
    nelua_abort();
  }
}
nlmulret_nlboolean_nlstring_nelua_span_string_ nelua_gmatch_next(nelua_GMatchState_ptr state, nlstring it) {
  bool ok = false;
  volatile nlstring matched = {0};
  nelua_span_string_ captures = {0};
  nlmulret_nlisize_nlisize _asgnret_1 = nelua_StrPatt_1_match((&state->ms), state->init);
  intptr_t startpos = _asgnret_1.r1;
  intptr_t endpos = _asgnret_1.r2;
  if((endpos != -1)) {
    ok = true;
    state->init = endpos;
    matched = (nlstring){.data = ((nluint8_arr0_ptr)(&state->ms.source.data[startpos])), .size = (uintptr_t)(endpos - startpos)};
    nelua_assert_line_15((state->ms.numcaptures <= 8), ((nlstring){(uint8_t*)"too many captures", 17}));
    for(intptr_t i = 0, _end = state->ms.numcaptures; i < _end; i = i + 1) {
      nlmulret_nlboolean_nlstring_nelua_StrPattCapture _asgnret_2 = nelua_StrPatt_1_get_capture((&state->ms), i);
      bool ok_1 = _asgnret_2.r1;
      nlstring capstr = _asgnret_2.r2;
      nelua_StrPattCapture capture = _asgnret_2.r3;
      nelua_assert_line_16(ok_1, capstr);
      nelua_assert_line_17((!nelua_StrPattCapture_is_position((&capture))), ((nlstring){(uint8_t*)"position capture not supported yet", 34}));
      (((nlstring_arr8_cast*)&state->captures)->a).v[i] = capstr;
    }
    captures = (nelua_span_string_){.data = ((nlstring_arr0_ptr)(&(((nlstring_arr8_cast*)&state->captures)->a).v[0])), .size = (uintptr_t)state->ms.numcaptures};
  }
  return (nlmulret_nlboolean_nlstring_nelua_span_string_){ok, matched, captures};
}
nlmulret_function_AUXgMx1BRVnTYeGb_nelua_GMatchState_nlstring nelua_nlstring_gmatchview_1(nlstring s, nlstring pattern, nlniltype init) {
  intptr_t init_2 = 1;
  nelua_GMatchState state = (nelua_GMatchState){.ms = nelua_StrPatt_1_create(s, pattern, false), .init = (init_2 - 1)};
  return (nlmulret_function_AUXgMx1BRVnTYeGb_nelua_GMatchState_nlstring){nelua_gmatch_next, state, (nlstring){0}};
}
void nelua_assert_line_18(bool cond, nlstring msg) {
  if(NELUA_UNLIKELY(!cond)) {
    nelua_write_stderr("/home/bart/projects/nelua/nelua-lang/lib/detail/strconv.nelua\033[1m:40:20: \033[31m\033[1mruntime error: \033[0m\033[1m", 105, false);
    nelua_write_stderr((const char*)msg.data, msg.size, false);
    nelua_write_stderr("\033[0m\n  assert(base >= 2 and base <= 36, \"base out of range\")\n                   \033[1m\033[32m^\033[0m\033[35m~~~~~~~~~~~~~\033[0m\n", 117, true);
    nelua_abort();
  }
}
nlmulret_nlboolean_nlint64 nelua_strconv_1_str2int(nlstring s, uint64_t base) {
  if((s.size == 0)) {
    return (nlmulret_nlboolean_nlint64){false, 0};
  }
  uintptr_t pos = 0U;
  while(((pos < s.size) && nelua_strchar_1_isspace(s.data[pos]))) {
    pos = (pos + 1);
  }
  if((pos >= s.size)) {
    return (nlmulret_nlboolean_nlint64){false, 0};
  }
  bool neg = false;
  if((s.data[pos] == 45U)) {
    pos = (pos + 1);
    neg = true;
  } else if((s.data[pos] == 43U)) {
    pos = (pos + 1);
  }
  if((base == 0)) {
    base = 10U;
    if(((s.data[pos] == 48U) && ((pos + 1) < s.size))) {
      uint8_t bc = s.data[(pos + 1)];
      if(((bc == 98U) || (bc == 66U))) {
        base = 2U;
        pos = (pos + 2);
      } else if(((bc == 120U) || (bc == 88U))) {
        base = 16U;
        pos = (pos + 2);
      }
    }
  }
  nelua_assert_line_18(((base >= 2) && (base <= 36)), ((nlstring){(uint8_t*)"base out of range", 17}));
  uint64_t n = 0U;
  while((pos < s.size)) {
    uint64_t x = (uint64_t)nelua_strchar_1_getbasedigit(s.data[pos]);
    if((x >= base)) {
      break;
    }
    n = ((n * base) + x);
    pos = (pos + 1);
  }
  while(((pos < s.size) && nelua_strchar_1_isspace(s.data[pos]))) {
    pos = (pos + 1);
  }
  if((pos != s.size)) {
    return (nlmulret_nlboolean_nlint64){false, 0};
  }
  if(neg) {
    n = (-n);
  }
  return (nlmulret_nlboolean_nlint64){true, (int64_t)n};
}
nlstring nelua_strconv_1_int2str_1(uintptr_t x, nlniltype base) {
  if((x == 0)) {
    return nelua_nlstring_copy(((nlstring){(uint8_t*)"0", 1}));
  }
  nluint8_arr48 buf;
  uintptr_t pos = 47U;
  bool neg = (x < 0);
  while((x != 0)) {
    uintptr_t quot = (x / 10U);
    uintptr_t rema = (x - (quot * 10U));
    x = quot;
    buf.v[pos] = (uint8_t)(rema + 48);
    pos = (pos - 1);
  }
  if(neg) {
    buf.v[pos] = 45U;
    pos = (pos - 1);
  }
  buf.v[pos] = 0U;
  return nelua_nlstring_copy((nlstring){.data = ((nluint8_arr0_ptr)(&buf.v[(pos + 1)])), .size = ((48 - pos) - 1)});
}
nlstring nelua_tostring_1(uint64_t x) {
  return nelua_strconv_1_int2str_1((uintptr_t)x, NELUA_NIL);
}
nlstring nelua_cstring2string(const char* s) {
  if(s == NULL) {
    return (nlstring){0};
  }
  uintptr_t size = strlen(s);
  if(size == 0) {
    return (nlstring){0};
  }
  return (nlstring){(uint8_t*)s, size};
}
void nelua_assert_line_19(bool cond, nlstring msg) {
  if(NELUA_UNLIKELY(!cond)) {
    nelua_write_stderr("/home/bart/projects/nelua/nelua-lang/lib/string.nelua\033[1m:949:12: \033[31m\033[1mruntime error: \033[0m\033[1m", 98, false);
    nelua_write_stderr((const char*)msg.data, msg.size, false);
    nelua_write_stderr("\033[0m\n    assert(ok, 'malformed integer')\n           \033[1m\033[32m^\033[0m\033[35m~\033[0m\n", 77, true);
    nelua_abort();
  }
}
int64_t nelua_tointeger_1(char* x, nlniltype base) {
  nlmulret_nlboolean_nlint64 _asgnret_1 = nelua_strconv_1_str2int(nelua_cstring2string(x), 0U);
  bool ok = _asgnret_1.r1;
  int64_t i = _asgnret_1.r2;
  nelua_assert_line_19(ok, ((nlstring){(uint8_t*)"malformed integer", 17}));
  return i;
}
uintptr_t nelua_lhash(nluint8_arr0_ptr data, uintptr_t len, uintptr_t seed, uintptr_t step) {
  seed = (seed ^ len);
  while((len >= step)) {
    seed = (seed ^ (((seed << 5) + (seed >> 2)) + data[(len - 1)]));
    len = (len - step);
  }
  return seed;
}
uintptr_t nelua_hash_long(nelua_span_uint8_ data) {
  return nelua_lhash(data.data, data.size, 0x9e3779b9ULL, ((data.size >> 5) + 1));
}
uintptr_t nelua_hash_hash_1(nlstring v) {
  return nelua_hash_long((nelua_span_uint8_){.data = v.data, .size = v.size});
}
uintptr_t nelua_ceilidiv(uintptr_t x, uintptr_t y) {
  return (((x + y) - 1) / y);
}
uintptr_t nelua_hashmod(uintptr_t h, uintptr_t n) {
  return (h % ((n - 1) | 1));
}
uintptr_t nelua_roundpow2(uintptr_t n) {
  if(((n & (n - 1)) == 0)) {
    return n;
  }
  n = (n | (n >> 1));
  n = (n | (n >> 2));
  n = (n | (n >> 4));
  n = (n | (n >> 8));
  n = (n | (n >> 16));
  n = (n | (n >> 32));
  n = (n + 1);
  return n;
}
nlmulret_nlusize_nlusize_nlusize nelua_hashmap_string__boolean___find(nelua_hashmap_string__boolean__ptr self, nlstring key) {
  uintptr_t bucket_index = nelua_hashmod(nelua_hash_hash_1(key), self->buckets.size);
  uintptr_t prev_node_index = 0xffffffffffffffffULL;
  if(NELUA_UNLIKELY((self->buckets.size == 0))) {
    return (nlmulret_nlusize_nlusize_nlusize){0xffffffffffffffffULL, prev_node_index, bucket_index};
  }
  uintptr_t node_index = (*nelua_span_usize____atindex((&self->buckets), bucket_index));
  while((node_index != 0xffffffffffffffffULL)) {
    nelua_hashmapnode_string__boolean__ptr node = (&(*nelua_span_hashmapnode_string__boolean_____atindex((&self->nodes), node_index)));
    if(NELUA_LIKELY(nelua_nlstring___eq(node->key, key))) {
      return (nlmulret_nlusize_nlusize_nlusize){node_index, prev_node_index, bucket_index};
    }
    prev_node_index = node_index;
    node_index = node->next;
  }
  return (nlmulret_nlusize_nlusize_nlusize){node_index, prev_node_index, bucket_index};
}
void nelua_hashmap_string__boolean__rehash(nelua_hashmap_string__boolean__ptr self, uintptr_t bucket_count) {
  uintptr_t min_buckets_count = nelua_ceilidiv((self->size * 100), 75U);
  if((bucket_count < min_buckets_count)) {
    bucket_count = min_buckets_count;
  }
  bucket_count = nelua_roundpow2(bucket_count);
  uintptr_t node_count = nelua_ceilidiv((bucket_count * 75U), 100U);
  if(((bucket_count > 0) && (node_count <= self->size))) {
    node_count = (self->size + 1);
  }
  if((((node_count < self->nodes.size) && (self->nodes.size > 0)) && (node_count > 0))) {
    uintptr_t j = 0U;
    while(((j < self->nodes.size) && (*nelua_span_hashmapnode_string__boolean_____atindex((&self->nodes), j)).filled)) {
      j = (j + 1);
    }
    for(uintptr_t i = j, _end = self->nodes.size; i < _end; i = i + 1) {
      if((*nelua_span_hashmapnode_string__boolean_____atindex((&self->nodes), i)).filled) {
        (*nelua_span_hashmapnode_string__boolean_____atindex((&self->nodes), j)) = (*nelua_span_hashmapnode_string__boolean_____atindex((&self->nodes), i));
        j = (j + 1);
      }
    }
    for(uintptr_t i = j, _end = self->nodes.size; i < _end; i = i + 1) {
      (*nelua_span_hashmapnode_string__boolean_____atindex((&self->nodes), i)) = (nelua_hashmapnode_string__boolean_){0};
    }
  }
  self->nodes = nelua_GeneralAllocator_xspanrealloc0_1((&self->allocator), self->nodes, node_count);
  self->buckets = nelua_GeneralAllocator_xspanrealloc_3((&self->allocator), self->buckets, bucket_count);
  nelua_memory_spanset_1(self->buckets, 0xffffffffffffffffULL);
  uintptr_t free_index = 0xffffffffffffffffULL;
  for(intptr_t i = (intptr_t)(self->nodes.size - 1); i >= 0; i = i + -1) {
    nelua_hashmapnode_string__boolean__ptr node = (&(*nelua_span_hashmapnode_string__boolean_____atindex((&self->nodes), (uintptr_t)i)));
    if(node->filled) {
      node->next = 0xffffffffffffffffULL;
    } else {
      node->next = free_index;
      free_index = (uintptr_t)i;
    }
  }
  self->free_index = free_index;
  for(uintptr_t i = 0U, _end = self->nodes.size; i < _end; i = i + 1) {
    if((*nelua_span_hashmapnode_string__boolean_____atindex((&self->nodes), i)).filled) {
      nlmulret_nlusize_nlusize_nlusize _asgnret_1 = nelua_hashmap_string__boolean___find(self, (*nelua_span_hashmapnode_string__boolean_____atindex((&self->nodes), i)).key);
      uintptr_t node_index = _asgnret_1.r1;
      uintptr_t prev_node_index = _asgnret_1.r2;
      uintptr_t bucket_index = _asgnret_1.r3;
      if(NELUA_LIKELY((prev_node_index == 0xffffffffffffffffULL))) {
        (*nelua_span_usize____atindex((&self->buckets), bucket_index)) = i;
      } else {
        (*nelua_span_hashmapnode_string__boolean_____atindex((&self->nodes), prev_node_index)).next = i;
      }
      (*nelua_span_hashmapnode_string__boolean_____atindex((&self->nodes), i)).next = node_index;
    }
  }
}
uintptr_t nelua_hashmap_string__boolean___at(nelua_hashmap_string__boolean__ptr self, nlstring key) {
  if(NELUA_UNLIKELY((self->buckets.size == 0))) {
    nelua_hashmap_string__boolean__rehash(self, 8U);
  }
  nlmulret_nlusize_nlusize_nlusize _asgnret_1 = nelua_hashmap_string__boolean___find(self, key);
  uintptr_t node_index = _asgnret_1.r1;
  uintptr_t prev_node_index = _asgnret_1.r2;
  uintptr_t bucket_index = _asgnret_1.r3;
  if((node_index != 0xffffffffffffffffULL)) {
    return node_index;
  } else {
    uintptr_t node_index_1 = self->free_index;
    nelua_hashmapnode_string__boolean__ptr node = (&(*nelua_span_hashmapnode_string__boolean_____atindex((&self->nodes), node_index_1)));
    self->free_index = node->next;
    (*node) = (nelua_hashmapnode_string__boolean_){.key = key, .filled = true, .next = 0xffffffffffffffffULL};
    if(NELUA_LIKELY((prev_node_index == 0xffffffffffffffffULL))) {
      (*nelua_span_usize____atindex((&self->buckets), bucket_index)) = node_index_1;
    } else {
      (*nelua_span_hashmapnode_string__boolean_____atindex((&self->nodes), prev_node_index)).next = node_index_1;
    }
    self->size = (self->size + 1);
    if(NELUA_UNLIKELY(((self->size * 100) >= (self->buckets.size * 75U)))) {
      nelua_hashmap_string__boolean__rehash(self, nelua_ceilidiv((self->size * 200U), 75U));
    }
    return node_index_1;
  }
}
nlboolean_ptr nelua_hashmap_string__boolean____atindex(nelua_hashmap_string__boolean__ptr self, nlstring key) {
  return (&(*nelua_span_hashmapnode_string__boolean_____atindex((&self->nodes), nelua_hashmap_string__boolean___at(self, key))).value);
}
nlboolean_ptr nelua_hashmap_string__boolean__peek(nelua_hashmap_string__boolean__ptr self, nlstring key) {
  uintptr_t node_index = nelua_hashmap_string__boolean___find(self, key).r1;
  if((node_index != 0xffffffffffffffffULL)) {
    return (&(*nelua_span_hashmapnode_string__boolean_____atindex((&self->nodes), node_index)).value);
  }
  return (nlboolean_ptr)NULL;
}
FILE_ptr nelua_filestream__getfp(nelua_filestream_ptr self) {
  if((!(self->fs != NULL))) {
    return ((FILE_ptr)NULL);
  }
  return self->fs->fp;
}
nlmulret_nlstring_nlint64 nelua_geterrno(void) {
  return (nlmulret_nlstring_nlint64){nelua_cstring2string(strerror(errno)), (int64_t)errno};
}
nlmulret_nlboolean_nlstring_nlint64 nelua_filestream_flush(nelua_filestream_ptr self) {
  FILE_ptr fp = nelua_filestream__getfp(self);
  if((!(fp != NULL))) {
    return (nlmulret_nlboolean_nlstring_nlint64){false, ((nlstring){(uint8_t*)"attempt to use a closed file", 28}), -1};
  }
  if((fflush(fp) != 0)) {
    nlmulret_nlstring_nlint64 _ret_1 = nelua_geterrno();
    return (nlmulret_nlboolean_nlstring_nlint64){false, _ret_1.r1, _ret_1.r2};
  }
  return (nlmulret_nlboolean_nlstring_nlint64){true, (nlstring){0}, 0};
}
nlmulret_nlboolean_nlstring_nlint64 nelua_filestream_write_1(nelua_filestream_ptr self, nlstring __arg1) {
  FILE_ptr fp = nelua_filestream__getfp(self);
  if((!(fp != NULL))) {
    return (nlmulret_nlboolean_nlstring_nlint64){false, ((nlstring){(uint8_t*)"attempt to use a closed file", 28}), -1};
  }
  {
    nlstring s = __arg1;
    if((s.size > 0)) {
      bool ok = (fwrite((void*)s.data, 1U, (size_t)s.size, fp) == s.size);
      if((!ok)) {
        nlmulret_nlstring_nlint64 _ret_1 = nelua_geterrno();
        return (nlmulret_nlboolean_nlstring_nlint64){false, _ret_1.r1, _ret_1.r2};
      }
    }
  }
  return (nlmulret_nlboolean_nlstring_nlint64){true, ((nlstring){(uint8_t*)"", 0}), 0};
}
nlmulret_nlboolean_nlstring_nlint64 nelua_filestream_writef_1(nelua_filestream_ptr self, nlstring fmt, nlstring __arg1) {
  FILE_ptr fp = nelua_filestream__getfp(self);
  if((!(fp != NULL))) {
    return (nlmulret_nlboolean_nlstring_nlint64){false, ((nlstring){(uint8_t*)"attempt to use a closed file", 28}), -1};
  }
  nelua_stringbuilderT sb = {0};
  if((!nelua_stringbuilderT_writef_2((&sb), fmt, __arg1).r1)) {
    nlmulret_nlboolean_nlstring_nlint64 _mulret_1;
    _mulret_1.r1 = false;
    _mulret_1.r2 = ((nlstring){(uint8_t*)"not enough memory", 17});
    _mulret_1.r3 = 0;
    { /* defer */
      nelua_stringbuilderT_destroy((&sb));
    }
    return _mulret_1;
  }
  nlstring s = nelua_stringbuilderT_view((&sb));
  if((s.size > 0)) {
    size_t res = fwrite((void*)s.data, 1U, (size_t)s.size, fp);
    if((res != s.size)) {
      nlmulret_nlboolean_nlstring_nlint64 _mulret_2;
      _mulret_2.r1 = false;
      nlmulret_nlstring_nlint64 _ret_1 = nelua_geterrno();
      _mulret_2.r2 = _ret_1.r1;
      _mulret_2.r3 = _ret_1.r2;
      { /* defer */
        nelua_stringbuilderT_destroy((&sb));
      }
      return _mulret_2;
    }
  }
  nlmulret_nlboolean_nlstring_nlint64 _mulret_3;
  _mulret_3.r1 = true;
  _mulret_3.r2 = ((nlstring){(uint8_t*)"", 0});
  _mulret_3.r3 = 0;
  { /* defer */
    nelua_stringbuilderT_destroy((&sb));
  }
  return _mulret_3;
}
nlmulret_nlboolean_nlstring_nlint64 nelua_filestream_writef_2(nelua_filestream_ptr self, nlstring fmt) {
  FILE_ptr fp = nelua_filestream__getfp(self);
  if((!(fp != NULL))) {
    return (nlmulret_nlboolean_nlstring_nlint64){false, ((nlstring){(uint8_t*)"attempt to use a closed file", 28}), -1};
  }
  nelua_stringbuilderT sb = {0};
  if((!nelua_stringbuilderT_writef_3((&sb), fmt).r1)) {
    nlmulret_nlboolean_nlstring_nlint64 _mulret_1;
    _mulret_1.r1 = false;
    _mulret_1.r2 = ((nlstring){(uint8_t*)"not enough memory", 17});
    _mulret_1.r3 = 0;
    { /* defer */
      nelua_stringbuilderT_destroy((&sb));
    }
    return _mulret_1;
  }
  nlstring s = nelua_stringbuilderT_view((&sb));
  if((s.size > 0)) {
    size_t res = fwrite((void*)s.data, 1U, (size_t)s.size, fp);
    if((res != s.size)) {
      nlmulret_nlboolean_nlstring_nlint64 _mulret_2;
      _mulret_2.r1 = false;
      nlmulret_nlstring_nlint64 _ret_1 = nelua_geterrno();
      _mulret_2.r2 = _ret_1.r1;
      _mulret_2.r3 = _ret_1.r2;
      { /* defer */
        nelua_stringbuilderT_destroy((&sb));
      }
      return _mulret_2;
    }
  }
  nlmulret_nlboolean_nlstring_nlint64 _mulret_3;
  _mulret_3.r1 = true;
  _mulret_3.r2 = ((nlstring){(uint8_t*)"", 0});
  _mulret_3.r3 = 0;
  { /* defer */
    nelua_stringbuilderT_destroy((&sb));
  }
  return _mulret_3;
}
nltype nelua_require_io(nlniltype modname) {
  nelua_stderrfs = (nelua_FStream){.fp = stderr};
  nelua_io_stderr = (nelua_filestream){.fs = (&nelua_stderrfs)};
  return NELUA_NIL;
}
int nelua_C_va_arg_1(nlcvalist_ptr ap, nlniltype T) {
  int va;
  va = va_arg(*ap, int);
  return va;
}
void forkmon_killapp(int code) {
  sys_killwait(forkmon_root_pid, SIGUSR2);
  exit(code);
}
void forkmon_logf_1(nlstring fmt, nlstring __arg1) {
  if((!forkmon_quiet)) {
    if((!forkmon_no_colors)) {
      nelua_filestream_write_1((&nelua_io_stderr), sys_Colors_Yellow);
    }
    nelua_filestream_write_1((&nelua_io_stderr), ((nlstring){(uint8_t*)"[forkmon] ", 10}));
    nelua_filestream_writef_1((&nelua_io_stderr), fmt, __arg1);
    if((!forkmon_no_colors)) {
      nelua_filestream_write_1((&nelua_io_stderr), sys_Colors_Reset);
    }
    nelua_filestream_write_1((&nelua_io_stderr), ((nlstring){(uint8_t*)"\n", 1}));
    nelua_filestream_flush((&nelua_io_stderr));
  }
}
void forkmon_errorf_1(nlstring fmt) {
  if((!forkmon_no_colors)) {
    nelua_filestream_write_1((&nelua_io_stderr), sys_Colors_Red);
  }
  nelua_filestream_write_1((&nelua_io_stderr), ((nlstring){(uint8_t*)"[forkmon] ", 10}));
  nelua_filestream_writef_2((&nelua_io_stderr), fmt);
  if((!forkmon_no_colors)) {
    nelua_filestream_write_1((&nelua_io_stderr), sys_Colors_Reset);
  }
  nelua_filestream_write_1((&nelua_io_stderr), ((nlstring){(uint8_t*)"\n", 1}));
  nelua_filestream_flush((&nelua_io_stderr));
  forkmon_killapp(-1);
}
void forkmon_assertkill(bool cond, nlstring msg) {
  if((!cond)) {
    forkmon_errorf_1(msg);
  }
}
bool forkmon_filter_filename(nlstring filename) {
  for(int64_t i = 0, _end = (int64_t)forkmon_filter_patts_count; i < _end; i = i + 1) {
    nlstring patt = forkmon_filter_patts.v[i];
    if((nelua_nlstring_find_1(filename, patt, NELUA_NIL, NELUA_NIL).r1 != 0)) {
      return true;
    }
  }
  return false;
}
nlmulret_nlcint_nlcint forkmon_inotify_init_watch(char* filename, int mask) {
  int fd = inotify_init();
  forkmon_assertkill((fd >= 0), ((nlstring){(uint8_t*)nelua_strlit_1, 84}));
  int wd = inotify_add_watch(fd, filename, (uint32_t)mask);
  forkmon_assertkill((wd >= 0), ((nlstring){(uint8_t*)"failed to watch file after init", 31}));
  return (nlmulret_nlcint_nlcint){fd, wd};
}
char* nelua_string2cstring(nlstring s) {
  return (s.size == 0) ? (char*)"" : (char*)s.data;
}
bool forkmon_monitor_file(nlstring filename) {
  int inotify_mask = (((IN_MODIFY | IN_CREATE) | IN_DELETE_SELF) | IN_MOVE_SELF);
  if((forkmon_parent_inotify_fd >= 0)) {
    int inotify_wd = inotify_add_watch(forkmon_parent_inotify_fd, nelua_string2cstring(filename), (uint32_t)inotify_mask);
    forkmon_assertkill((inotify_wd >= 0), ((nlstring){(uint8_t*)"failed to watch a file", 22}));
    return false;
  }
  if((!forkmon_quiet)) {
    forkmon_logf_1(((nlstring){(uint8_t*)"watch '%s'", 10}), filename);
  }
  int pid = fork();
  forkmon_assertkill((pid >= 0), ((nlstring){(uint8_t*)"fork failed", 11}));
  if((pid == 0)) {
    setpgid(0, 0);
    return false;
  }
  forkmon_child_pid = pid;
  nlmulret_nlcint_nlcint _asgnret_1 = forkmon_inotify_init_watch(nelua_string2cstring(filename), inotify_mask);
  int inotify_fd = _asgnret_1.r1;
  int inotify_wd = _asgnret_1.r2;
  nluint8_arr1024 buf = {0};
  while(true) {
    long res = read(inotify_fd, (void*)NULL, 0U);
    if(((res == -1) && (errno == EINTR))) {
      forkmon_killapp(0);
    }
    sys_usleep(forkmon_restart_delay);
    inotify_rm_watch(inotify_fd, inotify_wd);
    for(int64_t i = 1; i <= 10; i = i + 1) {
      inotify_wd = inotify_add_watch(inotify_fd, nelua_string2cstring(filename), (uint32_t)inotify_mask);
      if((inotify_wd >= 0)) {
        break;
      }
      sys_usleep(forkmon_restart_delay);
    }
    forkmon_assertkill((inotify_wd >= 0), ((nlstring){(uint8_t*)"failed to rewatch file, does the file still exist?", 50}));
    long len = read(inotify_fd, (void*)(&buf), 1024U);
    if((len > 0)) {
      uint64_t now = sys_uticks();
      if(((now - forkmon_last_restart_ticks) <= forkmon_ignore_delay)) {
        continue;
      }
      forkmon_last_restart_ticks = now;
      bool wdchange = false;
      int64_t pos = 0;
      while((pos < len)) {
        inotify_event_ptr event = ((inotify_event_ptr)(&buf.v[pos]));
        if((event->wd == inotify_wd)) {
          wdchange = true;
          break;
        }
        pos = (int64_t)((pos + 16) + event->len);
      }
      if(wdchange) {
        forkmon_logf_1(((nlstring){(uint8_t*)"file '%s' changed, resuming from it ...", 39}), filename);
        forkmon_parent_inotify_fd = inotify_fd;
      } else {
        forkmon_logf_1(((nlstring){(uint8_t*)"some file changed, resuming from '%s' ...", 41}), filename);
        forkmon_parent_inotify_fd = -1;
        close(inotify_fd);
        nlmulret_nlcint_nlcint _asgnret_2 = forkmon_inotify_init_watch(nelua_string2cstring(filename), inotify_mask);
        inotify_fd = _asgnret_2.r1;
        inotify_wd = _asgnret_2.r2;
      }
      sys_killwait(pid, SIGUSR2);
      pid = fork();
      forkmon_assertkill((pid >= 0), ((nlstring){(uint8_t*)"fork failed", 11}));
      if((pid == 0)) {
        setpgid(0, 0);
        nlstring nowtext = nelua_tostring_1(now);
        setenv("FORKMON_RESTART_TICKS", nelua_string2cstring(nowtext), 1);
        nelua_nlstring_destroy((&nowtext));
        return true;
      }
      forkmon_child_pid = pid;
    }
  }
  return false;
}
bool forkmon_track_file_open(char* name) {
  if((!forkmon_initialized)) {
    return false;
  }
  nlcchar_arr4097 buf = {0};
  nlstring filename = sys_resolvpath(name, (char*)(&buf), 4097);
  if((((nelua_nlstring___eq(filename, ((nlstring){(uint8_t*)"", 0})) || (nelua_nlstring_find_1(filename, ((nlstring){(uint8_t*)"^/tmp", 5}), NELUA_NIL, NELUA_NIL).r1 != 0)) || (!forkmon_filter_filename(filename))) || (nelua_hashmap_string__boolean__peek((&forkmon_tracked_files), filename) != NULL))) {
    return false;
  }
  if((!forkmon_preload_disabled)) {
    unsetenv("LD_PRELOAD");
    forkmon_preload_disabled = true;
  }
  (*nelua_hashmap_string__boolean____atindex((&forkmon_tracked_files), nelua_nlstring_copy(filename))) = true;
  return forkmon_monitor_file(filename);
}
void forkmon_signal_handler(int signum) {
  if(forkmon_handling_signal) {
    return;
  }
  forkmon_handling_signal = true;
  if((forkmon_child_pid != 0)) {
    sys_killwait(forkmon_child_pid, SIGUSR2);
  }
  sys_killwait((-getpid()), SIGKILL);
  _exit(0);
  return;
}
void forkmon_parse_env(void) {
  char* quiet_env = getenv("FORKMON_QUIET");
  if((quiet_env != NULL)) {
    forkmon_quiet = true;
  }
  char* no_colors_env = getenv("FORKMON_NO_COLORS");
  if((no_colors_env != NULL)) {
    forkmon_no_colors = true;
  }
  char* filter_env = getenv("FORKMON_FILTER");
  if((!(filter_env != NULL))) {
    forkmon_errorf_1(((nlstring){(uint8_t*)nelua_strlit_2, 101}));
  }
  {
    nlmulret_function_AUXgMx1BRVnTYeGb_nelua_GMatchState_nlstring _asgnret_1 = nelua_nlstring_gmatchview_1(nelua_cstring2string(filter_env), ((nlstring){(uint8_t*)"[^;]+", 5}), NELUA_NIL);
    function_AUXgMx1BRVnTYeGb __fornext = _asgnret_1.r1;
    nelua_GMatchState __forstate = _asgnret_1.r2;
    nlstring __forit = _asgnret_1.r3;
    while(true) {
      bool __forcont;
      nlmulret_nlboolean_nlstring_nelua_span_string_ _asgnret_2 = __fornext((&__forstate), __forit);
      __forcont = _asgnret_2.r1;
      __forit = _asgnret_2.r2;
      if((!__forcont)) {
        break;
      }
      nlstring patt = __forit;
      {
        if((forkmon_filter_patts_count >= 32)) {
          forkmon_errorf_1(((nlstring){(uint8_t*)"max number of filter patterns reached", 37}));
        }
        forkmon_filter_patts.v[forkmon_filter_patts_count] = patt;
        forkmon_filter_patts_count = (forkmon_filter_patts_count + 1);
      }
    }
  }
  char* restart_delay_env = getenv("FORKMON_RESTART_DELAY");
  if((restart_delay_env != NULL)) {
    forkmon_restart_delay = (uint64_t)(nelua_tointeger_1(restart_delay_env, NELUA_NIL) * 1000);
  }
  char* ignore_delay_env = getenv("FORKMON_IGNORE_DELAY");
  if((ignore_delay_env != NULL)) {
    forkmon_ignore_delay = (uint64_t)(nelua_tointeger_1(ignore_delay_env, NELUA_NIL) * 1000);
  }
}
FILE_ptr fopen(const char* __restrict filename, const char* __restrict mode) {
  if((!(forkmon_orig_fopen != NULL))) {
    forkmon_orig_fopen = (forkmon_FopenFunc)dlsym(RTLD_NEXT, "fopen");
  }
  if(((nelua_nlstring___eq(nelua_cstring2string(mode), ((nlstring){(uint8_t*)"r", 1})) || nelua_nlstring___eq(nelua_cstring2string(mode), ((nlstring){(uint8_t*)"rb", 2}))) && sys_filexists(filename))) {
    forkmon_track_file_open(filename);
  }
  FILE_ptr fp = forkmon_orig_fopen(filename, mode);
  return fp;
}
FILE_ptr fopen64(const char* __restrict filename, const char* __restrict mode) {
  if((!(forkmon_orig_fopen64 != NULL))) {
    forkmon_orig_fopen64 = (forkmon_FopenFunc)dlsym(RTLD_NEXT, "fopen64");
  }
  if(((nelua_nlstring___eq(nelua_cstring2string(mode), ((nlstring){(uint8_t*)"r", 1})) || nelua_nlstring___eq(nelua_cstring2string(mode), ((nlstring){(uint8_t*)"rb", 2}))) && sys_filexists(filename))) {
    forkmon_track_file_open(filename);
  }
  FILE_ptr fp = forkmon_orig_fopen64(filename, mode);
  return fp;
}
int open(const char* __restrict path, int flags, ...) {
  if((!(forkmon_orig_open != NULL))) {
    forkmon_orig_open = (forkmon_OpenFunc)dlsym(RTLD_NEXT, "open");
  }
  int writeflags = (((O_WRONLY | O_RDWR) | O_CREAT) | O_APPEND);
  if((((flags & writeflags) == 0) && sys_filexists(path))) {
    forkmon_track_file_open(path);
  }
  va_list args;
  va_start(args, flags);
  int mode = nelua_C_va_arg_1((&args), NELUA_NIL);
  va_end(args);
  int fd = forkmon_orig_open(path, flags, mode);
  return fd;
}
void setup(void) {
  nelua_main(0, (nlcstring_ptr)NULL);
}
int nelua_main(int argc, char** argv) {
  nelua_require_io(NELUA_NIL);
  forkmon_root_pid = getpid();
  {
    signal(SIGUSR2, forkmon_signal_handler);
    signal(SIGTERM, forkmon_signal_handler);
    signal(SIGINT, forkmon_signal_handler);
    signal(SIGSEGV, forkmon_signal_handler);
    signal(SIGBUS, forkmon_signal_handler);
    signal(SIGABRT, forkmon_signal_handler);
    signal(SIGFPE, forkmon_signal_handler);
    forkmon_parse_env();
    forkmon_initialized = true;
  }
  return 0;
}
